{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Holy Core - User Docs","text":""},{"location":"#overview","title":"Overview","text":"<p>The HOLY CORE is an MCU class open-source core, made for learning and experimentation purposes, targetting hobbyists and very high stakes and critical industrial applications, like running PONG or DOOM.</p> <p>Target Adience</p> <p>The target audience of this document are people who just want to use the core in their own project (for whatever reason) or simply learn more about the HOLY CORE before building it / out of curiosity.</p> <p>If you are an RTL dev looking to modify the inner HDL of the HOLY CORE, refer to the DEV DOCS.</p> <p>If you are a learner and just want to build the core yourself, go back to the repo and read the main \"<code>readme</code>\" file to start learning.</p> <p>The system is not very configurable. It provides a fixed, slow and unefficient platform. Its only strength is that it works, is 100 % Compliant to RISC-V and is somewhat fast enough to run DOOM at slideshow grade speeds.</p> <p>Are you still here ? Do you still want to use this core ? Good, we don't need speed anyway, do we ?.</p> <p>Jokes aside, even though the HOLY CORE was not built with any sort of optimisation in mind, it was build to work and actually be usable while still being as simple as it can be in its architecture.</p> <p>You can easily modify it on the fly if you take a couple hours to figure out how the project is layed out, which is exactly what is explained in this document.</p>"},{"location":"#project-key-features","title":"Project Key Features","text":""},{"location":"#the-platform-soc","title":"The Platform / SoC","text":"<p>The project comes with a <code>fpga/holy_top.sv</code> file. The main wrapper provides all the basics that surrounds the core.</p> <ul> <li>The HOLY CORE</li> <li>A debug module (from Pulp PLatform)</li> <li>A CLINT (to have soft interrupts, timers and all that jazz)</li> <li>A PLIC (to have external interrupts support)</li> <li>A boot ROM</li> <li>A software framework (a shitty and non flexible library)</li> <li>External access AXI &amp; AXI LITE interface for integration on larger SoCs with actual peripherals</li> <li>The HOLY CORE Platform has no custom peripherals other than the one listed above. Generic peripherals are yours to add depending on your needs. Guidelines are given in the document, see Getting Started.</li> </ul>"},{"location":"#the-core-itself","title":"The Core Itself","text":"<ul> <li>A 32-bit RISC-V CPU</li> <li>100% RISC-V compliant (according to the RISCOF framework)</li> <li>A single cycle CPU, so simple in its architecture that even I wonders how it even run any program at all without breaking.</li> <li>Supports base ISA + privileged ISA (RV32I_Zicsr Privileged)</li> <li>Machine mode only</li> </ul>"},{"location":"#project-folder-structure","title":"Project Folder Structure","text":"<p>The HOLY CORE's repo is kinda special for you, user, as it was built primarly to teach its contents. The repo is thus divided in chapters but as a user, you'll mostly be interrested in the latest one, in this case : the folder 3_perf_edition/.</p> <p>Each chapter is a \"CPU project\" in itself and you you only be concerned about what is in this subfolder.</p> <pre><code>HOLY CORE COURSE\n\u251c\u2500\u2500 0_single_cycle_edition          Not suitable for real use\n\u2502   \u251c\u2500\u2500 ...\n\u251c\u2500\u2500 1_fpga_edition                  Not suitable for real use\n\u2502   \u251c\u2500\u2500 ...\n\u251c\u2500\u2500 2_soc_software_edition          Contains bugs on advanced programs\n\u2502   \u251c\u2500\u2500 ...\n\u251c\u2500\u2500 3_perf_edition\n\u2502   \u251c\u2500\u2500 Dockerfile                  Helper to quickly run RISCOF tests\n\u2502   \u251c\u2500\u2500 example_programs            Contains exmaple sofwtware and a makefile to build it \n\u2502   \u251c\u2500\u2500 fpga                        Contains the holy_top.sv wrapper &amp; real program simulation utils for debugging\n\u2502   \u251c\u2500\u2500 hc_lib                      Holy Core's library\n\u2502   \u251c\u2500\u2500 Makefile                    To cleanup the project when needed\n\u2502   \u251c\u2500\u2500 packages                    Holy Core interface and types definitions\n\u2502   \u251c\u2500\u2500 readme.md                   informative document\n\u2502   \u251c\u2500\u2500 requirements.txt            some CI bloat\n\u2502   \u251c\u2500\u2500 riscof                      Compliance test utils\n\u2502   \u251c\u2500\u2500 src                         Actual HDL code is here\n\u2502   \u251c\u2500\u2500 tb                          Module unit testing and basic CORE testing (quicker than riscof for quick validations)\n\u2502   \u2514\u2500\u2500 vendor                      Vendor pulled code\n\u251c\u2500\u2500 LICENSE                         \n\u251c\u2500\u2500 readme.md                       \n\u251c\u2500\u2500 setup.md                        \n\u251c\u2500\u2500 todo.md                         \n\u251c\u2500\u2500 user_docs\n\u2502   \u251c\u2500\u2500 docs\n\u2502   \u2514\u2500\u2500 mkdocs.yml\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>It depends on what you want to know.</p> <p>If you want to know how to get the HOLY CORE platform running on your FPGA, whithout caring about the actual usage yet, go to the Practical FPGA Usage Guidelines section.</p> <p>If you have the holy core platform up and running and just want to know how to make in run some program, start with Using the Holy Core Platform.</p>"},{"location":"#holy-core-platform","title":"Holy Core Platform","text":""},{"location":"#description-top-ios","title":"Description &amp; Top I/Os","text":"<p>Here is a scheme that recaps everything provided by the <code>holy_top.sv</code> top module :</p> <p></p> <p>As stated earlier, the project \"only\" provides a <code>holy_top.sv</code> file that contains all mandatory peripherals to ensure the debug, interrupts and timer support, as well as a fixed boot ROM.</p> <p>So let's just say you have complete freedom over the platform (manily because you have to add the basics like UART or GPIO by yourself).</p> <p>Here are the ports you will have to compose with :</p> Port Direction Width Description <code>clk</code> input 1 CPU clock <code>rst_n</code> input 1 Active low reset <code>periph_rst_n</code> input 1 Peripheral reset (active low) <code>m_axi_*</code> in/out - AXI4 Full interface to external RAM <code>m_axi_lite_*</code> in/out - AXI4-Lite interface (crossbar to external peripherals) <code>irq_in</code> input NUM_IRQS External interrupt requests <code>tck_i</code> input 1 (for debug module) JTAG clock <code>tms_i</code> input 1 (for debug module) JTAG mode select <code>trst_ni</code> input 1 (for debug module) JTAG reset (active low) <code>td_i</code> input 1 (for debug module) JTAG data in <code>td_o</code> output 1 (for debug module) JTAG data out <code>...</code> output - Some misc on chip debug signals (I gotta get rid of these one day but these are useful sometimes, so they remain) <code>tb_debug_req</code> input 1 \"FPGA\" test debug request to provoke a debug jump in a simulation environement <p>Note that we separate peripheral and CPU reset. This is because I did not succeed in having one single reset signal. I gotta make a propre reset controller that handles this but for now, when using this platform, it is better to hold CPU reset and perform a proper complete peripheral reset before releasing the CPU.</p> <p>Where are the parameters ?</p> <p>\"Paramters\" are not described here, the reason is in the next sub section ;)</p>"},{"location":"#external-interfaces-cache-usage-for-the-user-via-csrs","title":"External interfaces : Cache Usage for the User (Via CSRs)","text":"<p>Also note that we have 2 interface to exchange data with the \"outside world\" (i.e. the rest of your SoC) : <code>m_axi_*</code> and <code>m_axi_lite_*</code>.</p> <p>This is because the HOLY CORE has a small yet existent cache system, one for instructions (I$) and one for data (D$).</p> <p>Note</p> <p>You can disable D$ by setting the ONLY PARAMETER OF THE ENTIRE HOLY CORE : <code>DCACHE_EN</code> to 0 in the holy core's instantiation in <code>holy_top.sv</code>. You can also set the cache sizes depending on avalable FPGA resources in <code>holy_core.sv</code> in the cache instatiations. This is a pretty straight forwrd process if you alredy did some HDL work before. Otherwise, go and follow the holy core course ;)</p> <p>These caches MAY cause problems when trying to exchange data with MMIOs (data wise) and the debug module (instruction wise). These need to NOT be cached. This is why the HOLY CORE platforms allow the user to set uncached ranges using the following CSRs:</p> CSR NAME ADDRESS ROLE <code>flush_cache</code> 0x7c0 write 1 to flush the data cache <code>data_non_cachable_base</code> 0x7c1 base addr of non cachable data space <code>data_non_cachable_limit</code> 0x7c2 limit addr of non cachable space <code>instr_non_cachable_base</code> 0x7c3 base addr of non cachable instruction space <code>instr_non_cachable_limit</code> 0x7c4 limit addr of non cachable instruction space <p>Note</p> <p>See Address space section for generic address layout.</p> <p>For example, this code sets up averything exepct RAM space (starting at 0x80000000) and up as non cachable (this also sets PLIC as cachable, I gotta do something about that... but yeah who cares ?)</p> <pre><code># cache setup\n\nli t0, 0x00000000\nli t1, 0x7FFFFFFF\ncsrrw x0, 0x7C1, t0\ncsrrw x0, 0x7C2, t1\ncsrrw x0, 0x7C3, t0\ncsrrw x0, 0x7C4, t1\n</code></pre> <p>When you make a request to an uncache memory region, the request will be routeed to the AXI LITE interface and if the requested address is in the cached range, it take the AXI FULL route.</p>"},{"location":"#address-space","title":"Address space","text":"<p>The <code>holy_top.sv</code> module is considered a basic SoC as it already has some peripherals. It comes with a basic fixed memory map.</p> <p>Your own peripherals will be accessed via the \"external\" adress space, through the TOP axi interfaces.</p> Region Start Address End Address Do you have to add this ? Boot ROM <code>0x00000000</code> <code>0x0FFFFFFF</code> No, it's in <code>holy_top.sv</code> External Peripherals <code>0x10000000</code> <code>0x2FFFFFFF</code> YES, LITE requests here will go STRAIGHT to the outside world ! Debug Module <code>0x30000000</code> <code>0x3FFFFFFF</code> No, it's in <code>holy_top.sv</code> CLINT <code>0x40000000</code> <code>0x7FFFFFFF</code> No, it's in <code>holy_top.sv</code> External RAM <code>0x80000000</code> <code>0x8FFFFFFF</code> YES, LITE requests here will go STRAIGHT to the outside world ! PLIC <code>0x90000000</code> <code>0xFFFFFFFF</code> No, it's in <code>holy_top.sv</code> <p>Warning</p> <p>This <code>holy_top.sv</code> internal address map only applies to the AXI_LITE interface.</p> <p>That's because, in theory, AXI FULL being ONLY USED to retrieve RAM stored data.</p> <p>Therefore, AXI FULL requests coming from the HOLY CORE will ALL be DIRECTLY ROUTED to the main extermal <code>m_axi</code> interface. Refer to the little scheme in the intro description above if not clear.</p>"},{"location":"#cloking","title":"Cloking","text":"<p>My tests on a Zybo Z7-20 and Arty S7-50 resulted in a max speed of 32MHz, I usually run it at 30MHz to make sure I close timing. This is slow but who cares ?</p> <p>internal AXI \"busses\" runs at the same speed than the HOLY CORE. Overall, the whole system runs at the same speed and a single clock is needed.</p> <p>Because the CORE uses AXI interfaces, you can run the rest of you SoC at different clock speeds, as long as you have correct CDC techniques in place so that the axi handshakes happen without problems.</p>"},{"location":"#trapping","title":"Trapping","text":"<p>When a trap is triggered, the HOLY CORE jumps to the <code>mtvec</code> CSRs stored address, no offset will be applied and the trap handler has to test <code>mcause</code> to dertermine what to do.</p> <p>Trap Example</p> <p>You have the <code>example_programs/pong</code> example if you need software guidance on building interrupt software or guidance on handling exceptions.</p> <p>The HOLY CORE will then be flagged as in \"trap mode\" and will only exit that mode when <code>mret</code> is detected.</p> <p>Watch Out when Debugging !</p> <p>This means if you trigger a trap or an exception during debugging, reset the core after debugging and before restarting your program to reset the trap mode and avoid weird execution problems.</p>"},{"location":"#interrupts","title":"Interrupts","text":"<p>The HOLY CORE supports all types of machine mode interrupts and you can configure these by the usual standard RISC-V procedure using the associated CSRs (mstatus, mie, etc..). Refer to the CSR list in this document or the RISC-V specs for more infos and this will not be detailled here.</p> <p>Interrupt Example with UART</p> <p>You have the <code>example_programs/pong</code> example if you need software guidance on building interrupt software.</p> <p>If you read the top ports table, you saw that the <code>holy_top.sv</code> module has a <code>irq_in</code> port (<code>NUM_IRQS</code> wide). These are external interrupts commnig from whatever peripheral you want, this can be a UART controller, a GPIO interface, etc.</p> <p>These feed directly into the PLIC.</p>"},{"location":"#platform-level-interrupt-controller-plic","title":"Platform Level Interrupt Controller (PLIC)","text":"<p>Assrts <code>ext_irq</code> on the core.</p> <p>The PLIC takes external, async requests from <code>irq_in</code> and formulate a singl clear and synchronous external interrupt request for the HOLY CORE.</p> <p>In the trap handler, the HOLY CORE should then consult the PLIC to figure what perpheral caused the trap, handle it and then signal the PLIC this trap has been handled.</p> <p>Interrupt Example with UART</p> <p>This procedure is used in the <code>example_programs/pong</code> example if you need software guidance on building interrupt software.</p> <p>Here is the <code>PLIC</code> memory map :</p> Address Offset Register Description <code>0x0000</code> <code>ENABLE</code> Bitmask: enables/disables each interrupt source. Bits <code>[NUM_IRQS-1:0]</code>. <code>0x0004</code> <code>CONTEXT_CLAIM_COMPLETE</code> Read: claim highest priority pending IRQ. Write: complete IRQ by writing same ID back. <p>Info</p> <p>This PLIC module is not 100% Compliant to the PLIC specs but implements all the basic to handle interrupts in a standards \"ready to go\" way. It lacks advanced setting like priorities but who cares.</p> <p>Info</p> <p>Note this PLIC latches on incomming request when IDLING, meaning the RISING EDGE on <code>irq_in</code> is what causes an external interrupt request, even if it goes down before the core had time to handle it. This behavior can be modifiied in th HDL pretty easily if needed, as it was quickly added after inital developement (way more practical and adapted).</p>"},{"location":"#core-level-interrupt-controller-clint","title":"Core Level INTerrupt controller (CLINT)","text":"<p>Assrts <code>soft_irq</code> and <code>timer_irq</code> on the core.</p> <p>The CLINT is a standard one, pretty straight forward to use.</p> <p>Some timer and time comparator register are here to assert a timer interrupt (<code>timer_irq</code>). And a soft interrupt register will automatically assert <code>soft_irq</code>.</p> <p>Here is the <code>CLINT</code> memory map :</p> Address Offset Register Description <code>0x0000</code> <code>msip</code> Sofware interrupt, only the LSB will trigger the output interrupt request. Others will be ignored. <code>0x4000</code> <code>mtimecmp[31:0]</code> Low word for the 64 bits <code>mtimecmp</code> <code>0x4004</code> <code>mtimecmp[63:32]</code> High word for the 64 bits <code>mtimecmp</code> <code>0xBFF8</code> <code>mtime[31:0]</code> Low word for the 64 bits <code>mtime</code> <code>0xBFFC</code> <code>mtime[63:32]</code> High word for the 64 bits <code>mtime</code>"},{"location":"#nested-traps","title":"Nested traps","text":"<p>No nested traps support, did you really think I would implement that ?</p>"},{"location":"#default-boot-sequence","title":"Default BOOT sequence","text":"<p>When booting (after releasing CPU reset), the default PC will be 0x0 and All cache related CSRs will be set to declare the entre memory as non-cachable.</p> <p>This means the first requests (instructions fetch) will go directly to the boot ROM through the internal AXI LITE interface.</p> <p></p> <p>By default, the BOOT ROM contains an infinite loop (with some GPIO interaction to turn and LED on and off, to clearly signals the CPU is alive when using it on FPGA).</p> <p>The boot ROM can be modified in <code>./fpga/ROM/rom.S</code> where you'll have to run <code>make</code> to generate a verilog ROM from your assembly code. The ROM changes will only \"apply\" once your re-run the synthesis and implementation process.</p> <p>Having an infinite loop there \"parks\" the HOLY CORE and allows the user (you) to connect via OpenOCD/GDB and do whatever you want (especially load a program).</p> <p>Info</p> <p>More information on debugging in On-chip Debugging Solutions.</p> <p>TODO : add a real bootloading solution.</p>"},{"location":"#on-chip-debugging-solutions","title":"On-chip Debugging Solutions","text":""},{"location":"#context","title":"Context","text":"<p>Here is a little scheme of the setup (Explanations below):</p> <p></p> <p>The debug module is a great tool here, it acts as a master in the SoC, meaning, while connected to it via a debugger, we can poke registers to inspect what is going on int the peripherals, read memeory to check correcption or load an entirly new program in said memory ! This is both extremely powerful and useful.</p> <p>This debug module can also send debug requests to the core, making the HOLY CORE jump to the debug module's address space where we can make the core do whatever we want, but this complexity is abstracted away to the user, all the user actually do is send GDB debug commands to poke around and control the core.</p> <p>As stated before, by default, the CORE boots on the boot ROM where some infinite LED on/off loop await to put the core in a \"parked\" state (i.e. it will not go anywhere and stay stable).</p> <p>To get out of this loop, one can use a debugger.</p> <p>If you look closely at the SoC scheme or the top I/O table, you'll see seom \"JTAG SIGNALS\" Signals comming in and out of the <code>holy_top.sv</code> module.</p> <p>These JTAG signals talk directly with the debug module, which is not mine and pulled from a pulp platform's repo.</p> <p>The debug module's job is to translate JTAG debugging instructions into real CPU interactions to apply the said debugging instructions. This whole part is abstracted away for the user and is not relevant here.</p>"},{"location":"#debugging-setup","title":"Debugging Setup","text":"<p>Warning</p> <p>Before doing all this, a working SoC with memory and some perpherals available is mandatory ! Follows the Practical FPGA Usage Guidelines if you do not have this yet.</p> <p>To debug the core, you need the system to be running (i.e. no reset) and the core to be in a stable state (e.g. running a program or parked in an infinite loop).</p> <p>Note</p> <p>The section \"Practical FPGA Usage Guidelines\" will help you fulfil the first step of getting the core running and parked.</p> <p>Once this is done, you need a way to generate los famosos \"JTAG Signal\" to debug the the core. This will be done by a piece of software called OpenOCD. OpenOCD's role is to serve as a translation layer between your main debugger (we'll come to that in a sec) and your system.</p> <p>This software will run on your very own PC, from which you will conduct all debugging operations.</p> <p>But, you may already know that  your computer do not have any way to transport JTAG signals. This is a very important observation, in fact, all our computers have is USB ports. Well, lucky us ! Some cbles exist for that (called JTAG programming cables). This module will translate USB signal into real JTAG signals that the on chip debug module will understand.</p> <p>Note</p> <p>I recommend the HS2 because it's what I use, but you can use any cable that claims to convert USB into JTAG, just make sure it is supported by OpenOCD. I will not details how to adapt the setup to other programming cables.</p> <p>To recognize and use this cable, OpenOCD needs a config file, that is already written, but you may have to adapt it depending on your exact JTAG programming cable. You'll also need to route the JTAG singals from the cable into the <code>holy_top.sv</code> top ports using some FPGA constraints.</p> <p>Once everything is plugged in corectly, run :</p> <pre><code>openocd -f ./fpga/arty_S7/holy_core_openocd.cfg \n</code></pre> <p>With <code>holy_core_openocd.cfg</code> being the configuration file you adapted to your cable. Openocd should signal you it found the HOLY CORE's debug module and that it's waiting for instructions.</p> <p>You will then open gdb with an elf program you want to execute and connect like so :</p> <pre><code>riscv64-unknown-elf-gdb ./example_programs/pong/pong.elf\n\n(gdb)target remote :3333\n\nRemote debugging using :3333\n0x800004a4 in main ()\n\n(gdb) load\n\nLoading section .text, size 0x72c lma 0x80000000\nLoading section .rodata, size 0x10f lma 0x8000072c\nLoading section .rodata.str1.4, size 0x3 lma 0x8000083c\nStart address 0x80000000, load size 2110\nTransfer rate: 294 KB/sec, 703 bytes/write.\n\n(gdb) c\nContinuing.\n</code></pre> <p>And the program will then execute. You can use various GDB tricks to debug you programs, but these practical aspects are discussed in the software guidelines.</p>"},{"location":"#fpga-usage-guidelines","title":"FPGA Usage Guidelines","text":"<p>This part of the user guide is made to guide SoC designers integrate the HOLY CORE into their system and get it running.</p> <p>Recommended FPGA board : Arty S7-50. More details below.</p>"},{"location":"#how-to-actually-flash-the-holy-core-platform-on-my-fpga","title":"How to actually flash the HOLY CORE platform on my FPGA ?","text":"<p>This sub-part will be divided in 2 use cases (Xilinx and non-xilinx) so you can start exploring solutions right away.</p> <p>Info</p> <p>Before jumping into this part, take a minute to read the SoC description section to know what \"product\" you are dealing with and what you actually need to implement.</p> <p>Point of Attention Before Running Synthesis</p> <p>The <code>holy_top.sv</code> top module comes whith a bootROM to feed the the core with some basic instructions when releasing the CPU reset. You should build the said ROM before running synth to get a verilg ROM output. Make sure you check the code being built before building. I suggest you create a nop loop or a LED on/off loop. More info in BOOT ROM the dedicated section.</p>"},{"location":"#if-you-use-xilinx-fpgas","title":"If you use xilinx FPGAs","text":"<p>Using Xilinx's fpgas will greatly simply the task for you. Even though the <code>holy_top.sv</code> module is the main output product here, the care had to be ported to FPGA to be tested, and lucky you, I use Xilinx tools, more specifically, an arty s7-50 embedding a Spartan7 FPGA, some RAm, etc...</p> <p>That means you have a full TCL scripts to build an entire pre-made SoC that has</p> <ul> <li>RAM support using (see warning below)</li> <li>UART (and UART interrupts)</li> <li>I2C controller</li> <li>SPI controller</li> <li>An huge AXI interconnect</li> <li>An ILA for extreme debugging scenarios</li> <li>etc...</li> </ul> <p>Warning</p> <p>The RAM is only compatible with the ARTY S7-50, you'll need to get rid of this and add you own memory solution if you do not use this exact board.</p> <p>To get this \"starter SoC\" going :</p> <pre><code>(HOLY_CORE_COURSE/)$ vivado -source vivado -source ./3_perf_edition/fpga/arty_S7/holy_vivado_setup.tcl\n</code></pre> <p>Tip</p> <p>The entire libraries were built for this specific SoC configuration (with Xilinx's IPs) as well !</p> <p>If your board is not an arty, which is more than likely, you can still run the script, change the target and modify the few board dependant aspects, like the constraints and the RAM solution.</p> <p>If you still want to build an SoC from scratch, import all the source files (don't forget package and vendor folders !) and use <code>holy_top.sv</code> or its plain verilog wrapper <code>holy_top.v</code> in your SoC. Then it's just a matter of connecting tohe top signals and intreface just like you would do with any softcore on the market.</p> <p>FPGA Targets Contributions</p> <p>Contributions on this part are very welcome : If you make an SoC that works, don't hesitate to create a PR with a tcl script targeting your specific setup.</p>"},{"location":"#if-you-use-other-tools-than-xilinxs","title":"If you use other tools than Xilinx's","text":"<p>In this use case, import all the source files (don't forget package and vendor folders !) and use use the <code>holy_top.sv</code> or its plain verilog wrapper <code>holy_top.v</code> in your HDL / Design tool.</p> <p>Then connect the top singals according to the top signals table (clock, resets, debug module signals if needed, ...) and connect periherals using the AXI interfaces.</p> <p>AXI Full interface is (in theory) only used to retrieve RAM data, you can connect that directly to a RAM slave.</p> <p>If your synthesis tool do not provide any AXI LITE interconnect solutions, you will find some AXI Lite crossbar in the <code>vendor/</code> folder.</p> <p>Example</p> <p>Use <code>holy_top.sv</code> to see an exmaple of using the AXI Lite crossbar.</p>"},{"location":"#integration-in-an-soc-guidelines","title":"Integration in an SoC Guidelines","text":"<p>This part aims at giving a quick easy to follow guide to get a basic demo running as quickly as possible.</p> <p>You'll need to connect the following top pins like so:</p> Port What to do ? <code>clk</code> 30MHz clock generated by whatever clocking solution (max is 32MHz, safe is 25MHz) <code>rst_n</code> Active low push button, preferably comming from an reset controller (should wait for <code>periph_rst_n</code> to be fully reset) <code>periph_rst_n</code> Active low switch, preferably comming from an reset controller <code>irq_in</code> Nothing / GND for basic applications <code>tck_i</code> Nothing / GND for basic applications <code>tms_i</code> Nothing / GND for basic applications <code>trst_ni</code> High (1) for basic applications <code>td_i</code> Nothing / GND for basic applications <code>td_o</code> Nothing / GND for basic applications <code>pc/pc_next/instruction</code> useful basic debug signal, plug in an ILA to see if the core runs at first <p>Regarding the AXI interfaces, you'll need an interconnect solution.</p> <ul> <li>The <code>AXI</code> interface only needs to be plugged to RAM (not mandatory as cache is disabled in CSRs by default)</li> <li>The exernal <code>AXI LITE</code> needs to go to a basic peripherals, like a GPIO controller connected o an LED (default GPIO address in holy core library is 0x10010000)</li> </ul> <p>Once this basic setup synths, you are ready to go, you should start to worry about what happens once you release the <code>rst_n</code>, the default BOOT scenario is described here. Write a basic assebly program in the ROM that turns the LED on and off to check if the core is indeed running.</p> <p>First troubleshooting solutions if the HOLY CORE shows no signs of life is to leverage the simple yet useful debug signals like <code>pc</code> or <code>instruction</code> with an ILA, these signals mirror what the HOLY CORE pc is and what instruction is currently fetched.</p> <p>Tools like Vivado provides easy \"plug and play\" AXI interconnect solutions. Here is an examaple of a working basic SoC built around <code>holy_top.sv</code> and the associated memory map :</p> <p></p>"},{"location":"#fpga-resources-usage-core-caches-and-soc","title":"FPGA Resources Usage (Core, Caches and SoC)","text":"<p>Note</p> <p>This data was gathered through Synthesis &amp; Implementation runs made on Vivado, targetting an ARTY S7-50 board.</p> <p>The Holy Core itslef is pretty small and uses 4K LUTs and 6K FFs.</p> <p>With caches (noted '$' with I = Instruction and D = Data):</p> <ul> <li>D$ : Add 604 LUts + 500 FFs (and some BRAM ofc)</li> <li>I$ : Add 3520 LUTs + 2296 FFs (no BRAM)</li> </ul> <p>I$ is way larger because the HOLY CORE has no \"Frontend\", there is no speculative regime nor \"prefetching\" nonsense. Instead, instructions are fetched \"on the fly\", meaning the I$ behaves as a normal cache except we read in an async fashion (to avoid the BRAM's 1 cycles dealys on each instruction fetch HIT, thus literraly doubling performances of the I$), forcing the FPGA to syth the cache data as LUTs and FFs. I$ Size thus has a hug impact on the system's footprint and performances.</p> <p>Warning</p> <p>Note that caches also have <code>no_cache</code> version in the core's data path. This allows users to set non cachable range (using custom CSRs), when a Instruction fetch or a data request happens in these ranges, caches are bypassed and the request goes through these \"no cache\" modules. Both af these uses around 600 LUTs and 50 FFs.</p> <p>Note</p> <p>Note that the I$ is mandatory and the D$ is optional. Both caches can be modified in size (not the number of ways though).</p> <p>Regaring th SoC, here is a more generic utilization report:</p> Module LUTs FFs ALL COMBINED 8651 5975 clint 129 226 core 6381 4528 internal AXI LITE crossbar 794 152 plic 35 75 debug_module + its AXI converter 1600 1000 <p>The final occupation will be determined by your peripherals. In vivado, everything is heavy, especially AXI smartconnects. My final SoC built by the TCL script is 25K+ LUTs and FFs, which is pretty heavy, but this depends on your own SoC layout.</p>"},{"location":"#software-guidelines","title":"Software Guidelines","text":""},{"location":"#write-build","title":"Write &amp; Build","text":"<p>The HOLY CORE platform is as bare-metal as it gets.</p> <p>Software is very \"primitive\", yet you can build (almost) any bare metal C program an run it.</p> <p>Once you have a running SoC, the best way to get started is not through an extensive block of test but through exmaples.</p> <p>You'll find many exmaples in the <code>example_programs/</code> folder. As well as a Makefile with all the right flags.</p> <p>To build a program :</p> <pre><code>(exmaple_programs/)$ make APP=&lt;hello_world&gt;\n</code></pre> <p>You can replace hello_world with your app's folder name. You need a <code>startup.S</code> assembly file that will do all the neceassy stack and cache setup.</p> <p>More complex apps will oviously need more setup, you can consult the <code>exmaple_program/doom-riscv</code> DOOM example to see how larger apps can be set up.</p>"},{"location":"#executing-software","title":"Executing software","text":"<p>Once you have a valid <code>.elf</code> file you want to run, you'll need to load it into your system and order the HOLY CORE to execute it.</p> <p>Note</p> <p>If you didn't read the boot section, read it to have better context.</p> <p>By default, the core should be executing whatever is in the BOOT ROM once you release reset, hopefully, an infinite loop.</p> <p>The best way to load some other program if you didn't not add any bootloading solution (like me), you should use the debugger.</p> <p>In the <code>holy_core.sv</code> top module, the debug module is a bus master by default and has the power of accessing your SoC through the <code>AXI_LITE</code> external interface, including your memory solution (e.g. BRAM, DRAM controller, etc). GDB and OpenOCD will works as expected and will allow you to frelly control the execution flow.</p> <p>Adding a better bootloading solution is on my todo list.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>This User docs file was inpired (in its layout) by stnolting's one you can find here.</p>"},{"location":"data.md/","title":"Holy Core - Data Sheet","text":"<p>This docuent aims at giving quick references on misc data and acts as a quick \"cheat sheet\".</p>"},{"location":"data.md/#risc-v-csrs-list","title":"RISC-V CSRs list","text":"Name Address Type Reset Value Bit Layout <code>mstatus</code> 0x300 RW 0x00001800 Bit 3: MIE (Machine Interrupt Enable) / Bit 7: MPIE (Previous MIE) <code>misa</code> 0x301 RO 0x40140100 - <code>mie</code> 0x304 RW 0x00000000 Bit 3: MSIE (Software Interrupt Enable) / Bit 7: MTIE (Timer Interrupt Enable) / Bit 11: MEIE (External Interrupt Enable) <code>mtvec</code> 0x305 RW 0x00000000 Bits 31:2: Base address (DIRECT ADDR ONLY SUPPOTED) <code>mscratch</code> 0x340 RW 0x00000000 Bits 31:0: Scratch data (general-purpose) <code>mepc</code> 0x341 RW 0x00000000 Bits 31:0: Exception program counter address <code>mcause</code> 0x342 RW 0x00000000 Bit 31: Interrupt flag / Bits 30:0: Exception/Interrupt code <code>mtval</code> 0x343 RW 0x00000000 Bits 31:0: Exception-specific value (faulting address or instruction) <code>mip</code> 0x344 RO 0x00000000 Bit 3: MSIP (Software Interrupt Pending) / Bit 7: MTIP (Timer Interrupt Pending) / Bit 11: MEIP (External Interrupt Pending)"},{"location":"data.md/#debug-csrs","title":"Debug CSRs","text":"Name Address Type Reset Value Bit Layout <code>dcsr</code> 0x7B0 RW 0x00000000 Bit 2: Step (single-step enabled) / Bits 8:6: Cause (debug entry reason) / Bits 15: ebreakm <code>dpc</code> 0x7B1 RW 0x00000000 Bits 31:0: Debug program counter (PC when entering debug mode) <code>dscratch0</code> 0x7B2 RW 0x00000000 Bits 31:0: Debug scratch register (general-purpose) <code>dscratch1</code> 0x7B3 RW 0x00000000 Bits 31:0: Debug scratch register (general-purpose)"},{"location":"data.md/#custom-csrs-list","title":"Custom CSRs list","text":"Name Address Type Reset Value Function <code>flush_cache</code> 0x7C0 WO 0x00000000 Cache flush command. Writing any value triggers cache flush; resets to 0 on next cycle. <code>data_non_cachable_base</code> 0x7C1 RW 0x00000000 Data non-cacheable base address. Sets lower bound of non-cacheable memory region. <code>data_non_cachable_limit</code> 0x7C2 RW 0xFFFFFFFF Data non-cacheable limit address. Sets upper bound of non-cacheable memory region. <code>instr_non_cachable_base</code> 0x7C3 RW 0x00000000 Instruction non-cacheable base address. Sets lower bound of non-cacheable instruction region. <code>instr_non_cachable_limit</code> 0x7C4 RW 0xFFFFFFFF Instruction non-cacheable limit address. Sets upper bound of non-cacheable instruction region."},{"location":"data.md/#mcause-values-and-mtval-contents","title":"<code>mcause</code> Values and <code>mtval</code> Contents","text":"mcause[31] mcause[30:0] Type Exception/Interrupt mtval Contains 0 0 Exception Instruction address misaligned Target address from second_adder (J/B target) 0 2 Exception Illegal instruction Current fetch instruction 0 3 Exception Breakpoint (ebreak) Current PC 0 4 Exception Load address misaligned Target address from ALU (load address) 0 6 Exception Store address misaligned Target address from ALU (store address) 0 11 Exception Environment call from M-mode (ecall) 0 1 3 Interrupt Machine software interrupt (MSIP) \u2014 1 7 Interrupt Machine timer interrupt (MTIP) \u2014 1 11 Interrupt Machine external interrupt (MEIP) \u2014"},{"location":"dev_docs/","title":"Holy Core - Dev Docs","text":"<p>Spoiler : Not much to see here as the whole dev process is already deocumented through the courses.</p> <p>However, you'll find here some guidelines and simulation tips, as well as some notes for myself.</p>"},{"location":"dev_docs/#rtl-contributions-guidelines","title":"RTL Contributions Guidelines","text":"<p>If you want to modify the HDL and contribute, please know that I am not interrested in major architecture modifications, i.e. pipelining, superscallaring etc...</p> <p>When making an RTL change to a module, make sure you run the module's testbench, eventually add testcases to the said testbench, run the HOLY CORE quick testbench and then run the riscof test suite.</p> <p>More info in thr \"RTL Changes guidelines\" and \"Simulation Tips\".</p> <p>Typos fix are welcome changes.</p> <p>Docs betterifications, code optimisation / refoctorization or more efficient synth code structure are very welcome changes.</p>"},{"location":"dev_docs/#core-overview","title":"Core Overview","text":"<p>todo : redo + add master schemes and explain</p>"},{"location":"dev_docs/#rtl-changes-guidelines","title":"RTL Changes guidelines","text":"<p>todo : talk about procdure and guive some tips</p>"},{"location":"dev_docs/#simulation-tips","title":"Simulation Tips","text":"<p>For advance software debugging tips when using on FPGA, see the User docs : \"Using the Fpga/ Folder to build and Debug\" Section</p>"},{"location":"dev_docs/#navigating-and-using-the-tb-folder","title":"Navigating and Using the tb/ Folder","text":"<p>Fr those who did not go through  the entire course, here is how to simulate modules and the core to validate changes</p>"},{"location":"dev_docs/#debugging-riscof-tests-when-sht-goes-south","title":"Debugging RISCOF tests when sh*t goes south","text":"<p>todo : redirect to riscof readme, then explain the debug process</p>"},{"location":"dev_docs/#using-the-fpga-folder-to-simulate-software-execution","title":"Using the <code>fpga/</code> Folder to Simulate Software Execution=","text":"<p>The HOLY CORE codebase provides both unit testbenches</p>"}]}