{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"User Docs","text":""},{"location":"#overview","title":"Overview","text":"<p>The HOLY CORE is an MCU class open-source core, made for learning and experimentation purposes, targeting hobbyists and very high stakes and critical industrial applications, like running PONG or DOOM.</p> <p>Target Audience</p> <p>The target audience of this document are people who just want to use the core in their own project (for whatever reason) or simply learn more about the HOLY CORE before building it / out of curiosity.</p> <p>If you are an RTL dev looking to modify the inner HDL of the HOLY CORE, refer to the DEV DOCS.</p> <p>If you are a learner and just want to build the core yourself, go back to the repo and read the main \"readme\" file to start learning.</p> <p>The system is not very configurable. It provides a fixed, slow and inefficient platform. Its only strength is that it works, is 100% Compliant to RISC-V and is somewhat fast enough to run DOOM at slideshow grade speeds.</p> <p>Are you still here? Do you still want to use this core? Good, we don't need speed anyway, do we?.</p> <p>Jokes aside, even though the HOLY CORE was not built with any sort of optimisation in mind, it was built to work and actually be usable while still being as simple as it can be in its architecture.</p> <p>You can easily modify it on the fly if you take a couple hours to figure out how the project is laid out, which is exactly what is explained in this document as well as in the dev docs.</p>"},{"location":"#project-key-features","title":"Project Key Features","text":""},{"location":"#the-platform-soc","title":"The Platform / SoC","text":"<p>The project comes with a <code>fpga/holy_top.sv</code> file. This main wrapper provides all the basics that surrounds the core.</p> <ul> <li>The HOLY CORE</li> <li>A debug module (from Pulp Platform)</li> <li>A CLINT (to have soft interrupts, timers and all that jazz)</li> <li>A PLIC (to have external interrupts support)</li> <li>A boot ROM</li> <li>A software framework (a shitty and non-flexible library)</li> <li>External access AXI &amp; AXI LITE interface for integration on larger SoCs with actual peripherals</li> <li>The HOLY CORE Platform has no custom peripherals other than the ones listed above. Generic peripherals are yours to add depending on your needs. Guidelines are given in the document, see Getting Started.</li> </ul>"},{"location":"#the-core-itself","title":"The Core Itself","text":"<ul> <li>A 32-bit RISC-V CPU</li> <li>100% RISC-V compliant (according to the RISCOF framework)</li> <li>A single cycle CPU, so simple in its architecture that even I wonder how it even runs any program at all without breaking.</li> <li>Supports base ISA + M extension + privileged ISA (RV32I_Zicsr Privileged)</li> <li>Machine mode only</li> </ul>"},{"location":"#project-folder-structure","title":"Project Folder Structure","text":"<p>The HOLY CORE's repo is kinda special for you, user, as it was built primarily to teach its contents. The repo is thus divided in chapters but as a user, you'll mostly be interested in the latest one, in this case: the folder 3_perf_edition/.</p> <p>Each chapter is a \"CPU project\" in itself and you will only be concerned about what is in this subfolder.</p> <pre><code>HOLY CORE COURSE\n\u251c\u2500\u2500 0_single_cycle_edition          Not suitable for real use\n\u2502   \u251c\u2500\u2500 ...\n\u251c\u2500\u2500 1_fpga_edition                  Not suitable for real use\n\u2502   \u251c\u2500\u2500 ...\n\u251c\u2500\u2500 &lt;latest_edition&gt;          Contains bugs on advanced programs\n\u2502   \u251c\u2500\u2500 ...\n\u251c\u2500\u2500 3_perf_edition\n\u2502   \u251c\u2500\u2500 Dockerfile                  Helper to quickly run RISCOF tests\n\u2502   \u251c\u2500\u2500 example_programs            Contains example software and a makefile to build it \n\u2502   \u251c\u2500\u2500 fpga                        Contains the holy_top.sv wrapper &amp; real program simulation utils for debugging\n\u2502   \u251c\u2500\u2500 hc_lib                      Holy Core's library\n\u2502   \u251c\u2500\u2500 Makefile                    To cleanup the project when needed\n\u2502   \u251c\u2500\u2500 packages                    Holy Core interface and types definitions\n\u2502   \u251c\u2500\u2500 readme.md                   informative document\n\u2502   \u251c\u2500\u2500 requirements.txt            some CI bloat\n\u2502   \u251c\u2500\u2500 riscof                      Compliance test utils\n\u2502   \u251c\u2500\u2500 src                         Actual HDL code is here\n\u2502   \u251c\u2500\u2500 tb                          Module unit testing and basic CORE testing (quicker than riscof for quick validations)\n\u2502   \u2514\u2500\u2500 vendor                      Vendor pulled code\n\u251c\u2500\u2500 LICENSE                         \n\u251c\u2500\u2500 readme.md                       \n\u251c\u2500\u2500 setup.md                        \n\u251c\u2500\u2500 todo.md                         \n\u2514\u2500\u2500 user_docs\n    \u251c\u2500\u2500 docs\n    \u2514\u2500\u2500 mkdocs.yml\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>It depends on what you want to know.</p> <ul> <li>If you want a really quick guide to just build a bitstream in vivado / run basic simulation, go to the quickstart guide.</li> <li>If you have the holy core platform up and running and just want to know how to use it for your projects, start with Using the Holy Core Platform</li> <li>If you want to know how to build a HOLY CORE based SoC ang get it running on your own FPGA platform, without caring about the actual software usage (yet), go to the Practical FPGA Usage Guidelines section.</li> </ul>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Note</p> <p>Get the HOLY CORE running in simulation or on FPGA hardware. This part targets people who have the exact right setup and just want a quick demo running before moving on to actually using the core.</p>"},{"location":"#quick-reference","title":"Quick Reference","text":"Task Command Run simulation <code>cd &lt;latest_edition&gt;/fpga &amp;&amp; make</code> Rebuild ROM <code>cd &lt;latest_edition&gt;/fpga/ROM &amp;&amp; make</code> Run unit tests <code>cd &lt;edition&gt;/tb &amp;&amp; pytest test_runner.py</code> Generate bitstream <code>vivado -source .../arty_S7/holy_vivado_setup.tcl</code> Start debug server <code>openocd -f .../arty_S7/holy_core_openocd.cfg</code> Load program via GDB <code>riscv64-unknown-elf-gdb &lt;elf&gt;</code> \u2192 <code>target remote :3333</code> \u2192 <code>load</code>"},{"location":"#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have the appropriate tools installed depending on your target.</p>"},{"location":"#simulation","title":"Simulation","text":"<ul> <li>Cocotb \u2014 Python-based hardware verification framework</li> <li>Verilator \u2014 open-source Verilog simulator</li> <li>GTKWave \u2014 waveform viewer (optional, for debugging, you can use your favorite tool here)</li> </ul>"},{"location":"#fpga","title":"FPGA","text":"<p>To use the HOLY_CORE on FPGA quickly, you need Vivado (Xilinx toolchain), required for quick bitstream generation using the TCL script.</p> <p>The base SoC comes with a simple ROM that blinks an LED, to load other programs, you'll need to debug using the associated tools:</p> <ul> <li>OpenOCD \u2014 for JTAG debugging</li> <li>RISC-V GCC toolchain (<code>riscv64-unknown-elf-gcc</code>)</li> <li>A USB-JTAG adapter (e.g., Digilent HS2) for loading programs via GDB</li> </ul> <p>Full Setup Instructions</p> <p>See the Setup Manual/Prerequisites for detailed installation steps.</p>"},{"location":"#simulation-quickstart","title":"Simulation Quickstart","text":""},{"location":"#running-the-default-simulation","title":"Running the Default Simulation","text":"<p>From the repository root:</p> <pre><code>cd &lt;latest_edition&gt;/fpga\nmake\n</code></pre> <p>This compiles the boot ROM and runs the HOLY_CORE in simulation using Verilator and Cocotb.</p>"},{"location":"#writing-your-own-test-program","title":"Writing Your Own Test Program","text":"<ol> <li> <p>Edit the boot ROM assembly:</p> <pre><code>vim &lt;latest_edition&gt;/fpga/ROM/rom.S\n</code></pre> </li> <li> <p>Recompile the ROM:</p> <pre><code>cd &lt;latest_edition&gt;/fpga/ROM\nmake\n</code></pre> </li> <li> <p>Run the simulation:</p> <pre><code>cd ..\nmake\n</code></pre> </li> </ol>"},{"location":"#running-unit-tests","title":"Running Unit Tests","text":"<p>To run the module-level testbenches:</p> <pre><code>cd &lt;edition&gt;/tb\npytest test_runner.py\n</code></pre> <p>This executes quick reference tests on individual modules, including a basic HOLY_CORE integration test.</p>"},{"location":"#running-riscof-compliance-tests","title":"Running RISCOF Compliance Tests","text":"<p>For full ISA compliance verification:</p> <pre><code>cd &lt;latest_edition&gt;/riscof\n</code></pre> <p>Docker Available</p> <p>A Docker container is provided for easy RISCOF setup. See the README in that directory for details.</p>"},{"location":"#fpga-quickstart","title":"FPGA Quickstart","text":""},{"location":"#supported-boards","title":"Supported Boards","text":"Board Status Arty S7  Fully supported Zybo Z720  Needs update Basys3  Needs update <p>Portability</p> <p>The <code>&lt;latest_edition&gt;/fpga/holy_top.sv</code> module is vendor-agnostic. Vivado is only used to add peripherals (UART, etc.). You can create your own SoC in <code>fpga/&lt;your_platform&gt;/</code>. More infos in the more in depth guide</p>"},{"location":"#step-1-generate-the-bitstream","title":"Step 1 \u2014 Generate the Bitstream","text":"<pre><code>vivado -source &lt;latest_edition&gt;/fpga/arty_S7/holy_vivado_setup.tcl\n</code></pre> <p>Vivado will create the block design and start synthesis/implementation automatically.</p>"},{"location":"#step-2-flash-and-boot","title":"Step 2 \u2014 Flash and Boot","text":"<ol> <li>Program the FPGA with the generated bitstream</li> <li>Press the reset button (resets peripherals)</li> <li>Release the CPU reset switch (<code>SW2</code> on Arty S7 \u2014 check your board's constraints file)</li> </ol> <p>The CPU starts execution at <code>PC = 0x0</code>, running the boot ROM. By default, this blinks an LED in a loop.</p>"},{"location":"#step-3-load-custom-programs-via-jtag","title":"Step 3 \u2014 Load Custom Programs via JTAG","text":"<p>To run more complex software, use OpenOCD and GDB.</p> <p>Start the debug server:</p> <pre><code>openocd -f &lt;latest_edition&gt;/fpga/arty_S7/holy_core_openocd.cfg\n</code></pre> <p>JTAG Adapter Required</p> <p>This requires a USB-JTAG adapter. The config is tested with Digilent HS2 rev. A.</p> <p>If you have a different adapter, open an issue and we'll help you create a config file.</p> <p>Connect with GDB and load a program:</p> <pre><code>riscv64-unknown-elf-gdb &lt;latest_edition&gt;/example_programs/ping_pong/ping_pong.elf\n</code></pre> <pre><code>(gdb) target remote :3333\n(gdb) load\n(gdb) continue\n</code></pre> <p>The program is loaded at base address <code>0x80000000</code> and execution begins:</p> <p></p>"},{"location":"#holy-core-platform","title":"Holy Core Platform","text":""},{"location":"#description-top-ios","title":"Description &amp; Top I/Os","text":"<p>Here is a scheme that recaps everything provided by the <code>holy_top.sv</code> top module:</p> <p></p> <p>As stated earlier, the project \"only\" provides a <code>holy_top.sv</code> file that contains all mandatory peripherals to ensure the debug, interrupts and timer support, as well as a fixed boot ROM.</p> <p>So let's just say you have complete freedom over the platform (mainly because you have to add the basics like UART or GPIO by yourself).</p> <p>Here are the ports you will have to work with:</p> Port Direction Width Description <code>clk</code> input 1 CPU clock <code>rst_n</code> input 1 Active low reset <code>periph_rst_n</code> input 1 Peripheral reset (active low) <code>m_axi_*</code> in/out - AXI4 Full interface to external RAM <code>m_axi_lite_*</code> in/out - AXI4-Lite interface (crossbar to external peripherals) <code>irq_in</code> input NUM_IRQS External interrupt requests <code>tck_i</code> input 1 (for debug module) JTAG clock <code>tms_i</code> input 1 (for debug module) JTAG mode select <code>trst_ni</code> input 1 (for debug module) JTAG reset (active low) <code>td_i</code> input 1 (for debug module) JTAG data in <code>td_o</code> output 1 (for debug module) JTAG data out <code>...</code> output - Some misc on chip debug signals (I gotta get rid of these one day but these are useful sometimes, so they remain) <code>tb_debug_req</code> input 1 \"FPGA\" test debug request to provoke a debug jump in a simulation environment <p>Note that we separate peripheral and CPU reset. This is because I did not succeed in having one single reset signal. I gotta make a proper reset controller that handles this but for now, when using this platform, it is better to hold CPU reset and perform a proper complete peripheral reset before releasing the CPU.</p> <p>Where are the parameters?</p> <p>\"Parameters\" are not described here, the reason is in the next sub section ;)</p>"},{"location":"#external-interfaces-cache-usage-for-the-user-via-csrs","title":"External interfaces: Cache Usage for the User (Via CSRs)","text":"<p>Also note that we have 2 interfaces to exchange data with the \"outside world\" (i.e. the rest of your SoC): <code>m_axi_*</code> and <code>m_axi_lite_*</code>.</p> <p>This is because the HOLY CORE has a small yet existent cache system, one for instructions (I$) and one for data (D$).</p> <p>Note</p> <p>You can disable D$ by setting the ONLY PARAMETER OF THE ENTIRE HOLY CORE: <code>DCACHE_EN</code> to 0 in the holy core's instantiation in <code>holy_top.sv</code>. You can also set the cache sizes depending on available FPGA resources in <code>holy_core.sv</code> in the cache instantiations. This is a pretty straightforward process if you already did some HDL work before. Otherwise, go and follow the holy core course ;)</p> <p>These caches MAY cause problems when trying to exchange data with MMIOs (data wise) and the debug module (instruction wise). These need to NOT be cached. This is why the HOLY CORE platform allows the user to set uncached ranges using the following CSRs:</p> CSR NAME ADDRESS ROLE <code>flush_cache</code> 0x7c0 write 1 to flush the data cache <code>data_non_cachable_base</code> 0x7c1 base addr of non cachable data space <code>data_non_cachable_limit</code> 0x7c2 limit addr of non cachable space <code>instr_non_cachable_base</code> 0x7c3 base addr of non cachable instruction space <code>instr_non_cachable_limit</code> 0x7c4 limit addr of non cachable instruction space <p>Note</p> <p>See Address space section for generic address layout.</p> <p>For example, this code sets up everything except RAM space (starting at 0x80000000) and up as non cachable (this also sets PLIC as cachable, I gotta do something about that... but yeah who cares?)</p> <pre><code># cache setup\n\nli t0, 0x00000000\nli t1, 0x7FFFFFFF\ncsrrw x0, 0x7C1, t0\ncsrrw x0, 0x7C2, t1\ncsrrw x0, 0x7C3, t0\ncsrrw x0, 0x7C4, t1\n</code></pre> <p>When you make a request to an uncached memory region, the request will be routed to the AXI LITE interface and if the requested address is in the cached range, it takes the AXI FULL route.</p>"},{"location":"#address-space","title":"Address space","text":"<p>The <code>holy_top.sv</code> module is considered a basic SoC as it already has some peripherals. It comes with a basic fixed memory map.</p> <p>Your own peripherals will be accessed via the \"external\" address space, through the TOP axi interfaces.</p> Region Start Address End Address Do you have to add this? Boot ROM <code>0x00000000</code> <code>0x0FFFFFFF</code> No, it's in <code>holy_top.sv</code> External Peripherals <code>0x10000000</code> <code>0x2FFFFFFF</code> YES, LITE requests here will go STRAIGHT to the outside world! Debug Module <code>0x30000000</code> <code>0x3FFFFFFF</code> No, it's in <code>holy_top.sv</code> CLINT <code>0x40000000</code> <code>0x7FFFFFFF</code> No, it's in <code>holy_top.sv</code> External RAM <code>0x80000000</code> <code>0x8FFFFFFF</code> YES, LITE requests here will go STRAIGHT to the outside world! PLIC <code>0x90000000</code> <code>0xFFFFFFFF</code> No, it's in <code>holy_top.sv</code> <p>Warning</p> <p>This <code>holy_top.sv</code> internal address map only applies to the AXI_LITE interface.</p> <p>That's because, in theory, AXI FULL being ONLY USED to retrieve RAM stored data.</p> <p>Therefore, AXI FULL requests coming from the HOLY CORE will ALL be DIRECTLY ROUTED to the main external <code>m_axi</code> interface as it has no business to do with the internal component that are all accesses via uncached transaction, i.e. via AXI LITE.</p> <p>Refer to the scheme for a better visual explaination.</p>"},{"location":"#clocking","title":"Clocking","text":"<p>My tests on a Zybo Z7-20 and Arty S7-50 resulted in a max speed of 32MHz, I usually run it at 30MHz to make sure I close timing. This is slow but who cares?</p> <p>Internal AXI \"buses\" run at the same speed as the HOLY CORE. Overall, the whole system runs at the same speed and a single clock is needed.</p> <p>Because the CORE uses AXI interfaces, you can run the rest of your SoC at different clock speeds, as long as you have correct CDC techniques in place so that the axi handshakes happen without problems.</p>"},{"location":"#trapping","title":"Trapping","text":"<p>When a trap is triggered, the HOLY CORE jumps to the <code>mtvec</code> CSRs stored address, no offset will be applied and the trap handler has to test <code>mcause</code> to determine what to do.</p> <p>Trap Example</p> <p>You have the <code>example_programs/pong</code> example if you need software guidance on building interrupt software or guidance on handling exceptions.</p> <p>The HOLY CORE will then be flagged as in \"trap mode\" and will only exit that mode when <code>mret</code> is detected.</p> <p>Watch Out when Debugging!</p> <p>This means if you trigger a trap or an exception during debugging, reset the core after debugging and before restarting your program to reset the trap mode and avoid weird execution problems.</p>"},{"location":"#interrupts","title":"Interrupts","text":"<p>The HOLY CORE supports all types of machine mode interrupts and you can configure these by the usual standard RISC-V procedure using the associated CSRs (mstatus, mie, etc.). Refer to the CSR list in this document or the RISC-V specs for more info and this will not be detailed here.</p> <p>Interrupt Example with UART</p> <p>You have the <code>example_programs/pong</code> example if you need software guidance on building interrupt software.</p> <p>If you read the top ports table, you saw that the <code>holy_top.sv</code> module has a <code>irq_in</code> port (<code>NUM_IRQS</code> wide). These are external interrupts coming from whatever peripheral you want, this can be a UART controller, a GPIO interface, etc.</p> <p>These feed directly into the PLIC.</p>"},{"location":"#platform-level-interrupt-controller-plic","title":"Platform Level Interrupt Controller (PLIC)","text":"<p>Asserts <code>ext_irq</code> on the core.</p> <p>The PLIC takes external, async requests from <code>irq_in</code> and formulate a single clear and synchronous external interrupt request for the HOLY CORE.</p> <p>In the trap handler, the HOLY CORE should then consult the PLIC to figure what peripheral caused the trap, handle it and then signal the PLIC this trap has been handled.</p> <p>Interrupt Example with UART</p> <p>This procedure is used in the <code>example_programs/pong</code> example if you need software guidance on building interrupt software.</p> <p>Here is the <code>PLIC</code> memory map:</p> Address Offset Register Description <code>0x0000</code> <code>ENABLE</code> Bitmask: enables/disables each interrupt source. Bits <code>[NUM_IRQS-1:0]</code>. <code>0x0004</code> <code>CONTEXT_CLAIM_COMPLETE</code> Read: claim highest priority pending IRQ. Write: complete IRQ by writing same ID back. <p>Info</p> <p>This PLIC module is not 100% Compliant to the PLIC specs but implements all the basics to handle interrupts in a standards \"ready to go\" way. It lacks advanced settings like priorities but who cares.</p> <p>Info</p> <p>Note this PLIC latches on incoming request when IDLING, meaning the RISING EDGE on <code>irq_in</code> is what causes an external interrupt request, even if it goes down before the core had time to handle it. This behavior can be modified in the HDL pretty easily if needed, as it was quickly added after initial development (way more practical and adapted).</p>"},{"location":"#core-level-interrupt-controller-clint","title":"Core Level Interrupt Controller (CLINT)","text":"<p>Asserts <code>soft_irq</code> and <code>timer_irq</code> on the core.</p> <p>The CLINT is a standard one, pretty straightforward to use.</p> <p>Some timer and time comparator registers are here to assert a timer interrupt (<code>timer_irq</code>). And a soft interrupt register will automatically assert <code>soft_irq</code>.</p> <p>Here is the <code>CLINT</code> memory map:</p> Address Offset Register Description <code>0x0000</code> <code>msip</code> Software interrupt, only the LSB will trigger the output interrupt request. Others will be ignored. <code>0x4000</code> <code>mtimecmp[31:0]</code> Low word for the 64 bits <code>mtimecmp</code> <code>0x4004</code> <code>mtimecmp[63:32]</code> High word for the 64 bits <code>mtimecmp</code> <code>0xBFF8</code> <code>mtime[31:0]</code> Low word for the 64 bits <code>mtime</code> <code>0xBFFC</code> <code>mtime[63:32]</code> High word for the 64 bits <code>mtime</code>"},{"location":"#nested-traps","title":"Nested traps","text":"<p>No nested traps support, did you really think I would implement that?</p>"},{"location":"#default-boot-sequence","title":"Default BOOT sequence","text":"<p>When booting (after releasing CPU reset), the default PC will be 0x0 and All cache related CSRs will be set to declare the entire memory as non-cachable.</p> <p>This means the first requests (instructions fetch) will go directly to the boot ROM through the internal AXI LITE interface.</p> <p></p> <p>By default, the BOOT ROM contains an infinite loop (with some GPIO interaction to turn an LED on and off, to clearly signal the CPU is alive when using it on FPGA).</p> <p>The boot ROM can be modified in <code>./fpga/ROM/rom.S</code> where you'll have to run <code>make</code> to generate a verilog ROM from your assembly code. The ROM changes will only \"apply\" once you re-run the synthesis and implementation process.</p> <p>Having an infinite loop there \"parks\" the HOLY CORE and allows the user (you) to connect via OpenOCD/GDB and do whatever you want (especially load a program).</p> <p>Info</p> <p>More information on debugging in On-chip Debugging Solutions.</p> <p>TODO: add a real bootloading solution.</p>"},{"location":"#on-chip-debugging-solutions","title":"On-chip Debugging Solutions","text":""},{"location":"#context","title":"Context","text":"<p>Here is a little scheme of the setup (Explanations below):</p> <p></p> <p>The debug module is a great tool here, it acts as a master in the SoC, meaning, while connected to it via a debugger, we can poke registers to inspect what is going on in the peripherals, read memory to check corruption or load an entirely new program in said memory! This is both extremely powerful and useful.</p> <p>This debug module can also send debug requests to the core, making the HOLY CORE jump to the debug module's address space where we can make the core do whatever we want, but this complexity is abstracted away to the user, all the user actually does is send GDB debug commands to poke around and control the core.</p> <p>As stated before, by default, the CORE boots on the boot ROM where some infinite LED on/off loop awaits to put the core in a \"parked\" state (i.e. it will not go anywhere and stay stable).</p> <p>To get out of this loop, one can use a debugger.</p> <p>If you look closely at the SoC scheme or the top I/O table, you'll see some \"JTAG SIGNALS\" signals coming in and out of the <code>holy_top.sv</code> module.</p> <p>These JTAG signals talk directly with the debug module, which is not mine and pulled from a pulp platform's repo.</p> <p>The debug module's job is to translate JTAG debugging instructions into real CPU interactions to apply the said debugging instructions. This whole part is abstracted away for the user and is not relevant here.</p>"},{"location":"#debugging-setup","title":"Debugging Setup","text":"<p>Warning</p> <p>Before doing all this, a working SoC with memory and some peripherals available is mandatory! Follow the Practical FPGA Usage Guidelines if you do not have this yet.</p> <p>To debug the core, you need the system to be running (i.e. no reset) and the core to be in a stable state (e.g. running a program or parked in an infinite loop).</p> <p>Note</p> <p>The section \"Practical FPGA Usage Guidelines\" will help you fulfill the first step of getting the core running and parked.</p> <p>Once this is done, you need a way to generate los famosos \"JTAG Signal\" to debug the core. This will be done by a piece of software called OpenOCD. OpenOCD's role is to serve as a translation layer between your main debugger (we'll come to that in a sec) and your system.</p> <p>This software will run on your very own PC, from which you will conduct all debugging operations.</p> <p>But, you may already know that your computer does not have any way to transport JTAG signals. This is a very important observation, in fact, all our computers have is USB ports. Well, lucky us! Some cables exist for that (called JTAG programming cables). This module will translate USB signal into real JTAG signals that the on chip debug module will understand.</p> <p>Recommended JTAG Programming Cable</p> <p>I recommend the HS2 because it's what I use, but you can use any cable that claims to convert USB into JTAG, just make sure it is supported by OpenOCD. I will not detail how to adapt the setup to other programming cables.</p> <p>To recognize and use this cable, OpenOCD needs a config file, that is already written, but you may have to adapt it depending on your exact JTAG programming cable. You'll also need to route the JTAG signals from the cable into the <code>holy_top.sv</code> top ports using some FPGA constraints.</p> <p>Once everything is plugged in correctly, run:</p> <pre><code>openocd -f ./fpga/arty_S7/holy_core_openocd.cfg \n</code></pre> <p>With <code>holy_core_openocd.cfg</code> being the configuration file you adapted to your cable. OpenOCD should signal you it found the HOLY CORE's debug module and that it's waiting for instructions.</p> <p>You will then open gdb with an elf program you want to execute and connect like so:</p> <pre><code>riscv64-unknown-elf-gdb ./example_programs/pong/pong.elf\n\n(gdb)target remote :3333\n\nRemote debugging using :3333\n0x800004a4 in main ()\n\n(gdb) load\n\nLoading section .text, size 0x72c lma 0x80000000\nLoading section .rodata, size 0x10f lma 0x8000072c\nLoading section .rodata.str1.4, size 0x3 lma 0x8000083c\nStart address 0x80000000, load size 2110\nTransfer rate: 294 KB/sec, 703 bytes/write.\n\n(gdb) c\nContinuing.\n</code></pre> <p>And the program will then execute. You can use various GDB tricks to debug your programs, but these practical aspects are discussed in the software guidelines.</p>"},{"location":"#fpga-usage-guidelines","title":"FPGA Usage Guidelines","text":"<p>This part of the user guide is made to guide SoC designers to integrate the HOLY CORE into their system and get it running.</p> <p>Recommended FPGA board: Arty S7-50. More details below.</p>"},{"location":"#how-to-actually-flash-the-holy-core-platform-on-my-fpga","title":"How to actually flash the HOLY CORE platform on my FPGA?","text":"<p>This sub-part will be divided in 2 use cases (Xilinx and non-xilinx) so you can start exploring solutions right away.</p> <p>Info</p> <p>Before jumping into this part, take a minute to read the SoC description section to know what \"product\" you are dealing with and what you actually need to implement.</p> <p>Point of Attention Before Running Synthesis</p> <p>The <code>holy_top.sv</code> top module comes with a bootROM to feed the core with some basic instructions when releasing the CPU reset. You should build the said ROM before running synth to get a verilog ROM output. Make sure you check the code being built before building. I suggest you create a nop loop or a LED on/off loop. More info in BOOT ROM the dedicated section.</p>"},{"location":"#if-you-use-xilinx-fpgas","title":"If you use xilinx FPGAs","text":"<p>Using Xilinx's FPGAs will greatly simplify the task for you. Even though the <code>holy_top.sv</code> module is the main output product here, the care had to be ported to FPGA to be tested, and lucky you, I use Xilinx tools, more specifically, an arty s7-50 embedding a Spartan7 FPGA, some RAM, etc...</p> <p>That means you have full TCL scripts to build an entire pre-made SoC that has</p> <ul> <li>RAM support using (see warning below)</li> <li>UART (and UART interrupts)</li> <li>I2C controller</li> <li>SPI controller</li> <li>A huge AXI interconnect</li> <li>An ILA for extreme debugging scenarios</li> <li>etc...</li> </ul> <p>Warning</p> <p>The RAM is only compatible with the ARTY S7-50, you'll need to get rid of this and add your own memory solution if you do not use this exact board.</p> <p>To get this \"starter SoC\" going:</p> <pre><code>(HOLY_CORE_COURSE/)$ vivado -source vivado -source ./3_perf_edition/fpga/arty_S7/holy_vivado_setup.tcl\n</code></pre> <p>Tip</p> <p>The entire libraries were built for this specific SoC configuration (with Xilinx's IPs) as well!</p> <p>If your board is not an arty, which is more than likely, you can still run the script, change the target and modify the few board dependent aspects, like the constraints and the RAM solution.</p> <p>If you still want to build an SoC from scratch, import all the source files (don't forget package and vendor folders!) and use <code>holy_top.sv</code> or its plain verilog wrapper <code>holy_top.v</code> in your SoC. Then it's just a matter of connecting the top signals and interface just like you would do with any softcore on the market.</p> <p>FPGA Targets Contributions</p> <p>Contributions on this part are very welcome: If you make an SoC that works, don't hesitate to create a PR with a tcl script targeting your specific setup.</p>"},{"location":"#if-you-use-other-tools-than-xilinxs","title":"If you use other tools than Xilinx's","text":"<p>In this use case, import all the source files (don't forget package and vendor folders!) and use the <code>holy_top.sv</code> or its plain verilog wrapper <code>holy_top.v</code> in your HDL / Design tool.</p> <p>Then connect the top signals according to the top signals table (clock, resets, debug module signals if needed, ...) and connect peripherals using the AXI interfaces.</p> <p>AXI Full interface is (in theory) only used to retrieve RAM data, you can connect that directly to a RAM slave.</p> <p>If your synthesis tool does not provide any AXI LITE interconnect solutions, you will find some AXI Lite crossbar in the <code>vendor/</code> folder.</p> <p>Example</p> <p>Use <code>holy_top.sv</code> to see an example of using the AXI Lite crossbar.</p>"},{"location":"#integration-in-an-soc-guidelines","title":"Integration in an SoC Guidelines","text":"<p>This part aims at giving a quick easy to follow guide to get a basic demo running as quickly as possible on you own FPGA platform.</p> <p>You'll need to connect the following top pins like so:</p> Port What to do? <code>clk</code> 25MHz clock generated by whatever clocking solution (max is 30MHz, safe is 25MHz) <code>rst_n</code> Active low push button, preferably coming from a reset controller (should wait for <code>periph_rst_n</code> to be fully reset) <code>periph_rst_n</code> Active low switch, preferably coming from a reset controller <code>irq_in</code> Nothing / GND for basic applications <code>tck_i</code> Nothing / GND for basic applications <code>tms_i</code> Nothing / GND for basic applications <code>trst_ni</code> High (1) for basic applications <code>td_i</code> Nothing / GND for basic applications <code>td_o</code> Nothing / GND for basic applications <code>pc/pc_next/instruction</code> useful basic debug signal, plug in an ILA to see if the core runs at first <p>Regarding the AXI interfaces, you'll need an interconnect solution.</p> <ul> <li>The <code>AXI</code> interface only needs to be plugged to RAM (not mandatory as cache is disabled in CSRs by default)</li> <li>The external <code>AXI LITE</code> needs to go to a basic peripheral, like a GPIO controller connected to an LED (default GPIO address in holy core library is 0x10010000)</li> </ul> <p>Once this basic setup synths, you are ready to go, you should start to worry about what happens once you release the <code>rst_n</code>, the default BOOT scenario is described here. Write a basic assembly program in the ROM that turns the LED on and off to check if the core is indeed running.</p> <p>First troubleshooting solutions if the HOLY CORE shows no signs of life is to leverage the simple yet useful debug signals like <code>pc</code> or <code>instruction</code> with an ILA, these signals mirror what the HOLY CORE pc is and what instruction is currently fetched.</p> <p>Tools like Vivado provides easy \"plug and play\" AXI interconnect solutions. Here is an example of a working basic SoC built around <code>holy_top.sv</code> and the associated memory map:</p> <p></p>"},{"location":"#fpga-resources-usage-core-caches-and-soc","title":"FPGA Resources Usage (Core, Caches and SoC)","text":"<p>Note</p> <p>This data was gathered through Synthesis &amp; Implementation runs made on Vivado, targeting an ARTY S7-50 board.</p> <p>The Holy Core itself is pretty small and uses 4K LUTs and 6K FFs.</p> <p>With caches (noted '$' with I = Instruction and D = Data):</p> <ul> <li>D$: Add 604 LUTs + 500 FFs (and some BRAM ofc)</li> <li>I$: Add 3520 LUTs + 2296 FFs (no BRAM)</li> </ul> <p>I$ is way larger because the HOLY CORE has no \"Frontend\", there is no speculative regime nor \"prefetching\" nonsense. Instead, instructions are fetched \"on the fly\", meaning the I$ behaves as a normal cache except we read in an async fashion (to avoid the BRAM's 1 cycle delay on each instruction fetch HIT, thus literally doubling performance of the I$), forcing the FPGA to synth the cache data as LUTs and FFs. I$ size thus has a huge impact on the system's footprint and performance.</p> <p>Warning</p> <p>Note that caches also have <code>no_cache</code> version in the core's data path. This allows users to set non cachable range (using custom CSRs), when an Instruction fetch or a data request happens in these ranges, caches are bypassed and the request goes through these \"no cache\" modules. Both of these use around 600 LUTs and 50 FFs.</p> <p>Note</p> <p>Note that the I$ is mandatory and the D$ is optional. Both caches can be modified in size (not the number of ways though).</p> <p>Regarding the SoC, here is a more generic utilization report:</p> Module LUTs FFs ALL COMBINED 8651 5975 clint 129 226 core 6381 4528 internal AXI LITE crossbar 794 152 plic 35 75 debug_module + its AXI converter 1600 1000 <p>The final occupation will be determined by your peripherals. In vivado, everything is heavy, especially AXI smartconnects. My final SoC built by the TCL script is 25K+ LUTs and FFs, which is pretty heavy, but this depends on your own SoC layout.</p>"},{"location":"#software-guidelines","title":"Software Guidelines","text":""},{"location":"#write-build","title":"Write &amp; Build","text":"<p>The HOLY CORE platform is as bare-metal as it gets.</p> <p>Software is very \"primitive\", yet you can build (almost) any bare metal C program and run it.</p> <p>Once you have a running SoC, the best way to get started is not through an extensive block of test but through examples.</p> <p>You'll find many examples in the <code>example_programs/</code> folder. As well as a Makefile with all the right flags.</p> <p>To build a program:</p> <pre><code>(example_programs/)$ make APP=&lt;hello_world&gt;\n</code></pre> <p>You can replace hello_world with your app's folder name. You need a <code>startup.S</code> assembly file that will do all the necessary stack and cache setup.</p> <p>More complex apps will obviously need more setup, you can consult the <code>example_programs/doom-riscv</code> DOOM example to see how larger apps can be set up.</p>"},{"location":"#executing-software","title":"Executing software","text":"<p>Once you have a valid <code>.elf</code> file you want to run, you'll need to load it into your system and order the HOLY CORE to execute it.</p> <p>Note</p> <p>If you didn't read the boot section, read it to have better context.</p> <p>By default, the core should be executing whatever is in the BOOT ROM once you release reset, hopefully, an infinite loop.</p> <p>The best way to load some other program if you didn't add any bootloading solution (like me), you should use the debugger.</p> <p>In the <code>holy_core.sv</code> top module, the debug module is a bus master by default and has the power of accessing your SoC through the <code>AXI_LITE</code> external interface, including your memory solution (e.g. BRAM, DRAM controller, etc). GDB and OpenOCD will work as expected and will allow you to freely control the execution flow.</p> <p>Adding a better bootloading solution is on my todo list.</p>"},{"location":"#help-misc","title":"Help &amp; Misc","text":"<ul> <li> <p> Documentation</p> <p>A problem in the docs ? Open an issue.</p> </li> <li> <p> Issues &amp; Questions</p> <p>Having troubles you can't fix ? Open an issue on GitHub.</p> </li> <li> <p> Contributions</p> <p>PRs are welcome! This is true for this docs, adding tcl scripts or contributing to the RTL, but make sure you check the guidelines.</p> </li> </ul>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>This User docs file was inspired (in its layout) by stnolting's one you can find here.</p>"},{"location":"data.md/","title":"Data Sheet","text":"<p>This docuent aims at giving quick references on misc data and acts as a quick \"cheat sheet\".</p>"},{"location":"data.md/#risc-v-csrs-list","title":"RISC-V CSRs list","text":"Name Address Type Reset Value Bit Layout <code>mstatus</code> 0x300 RW 0x00001800 Bit 3: MIE (Machine Interrupt Enable) / Bit 7: MPIE (Previous MIE) <code>misa</code> 0x301 RO 0x40140100 - <code>mie</code> 0x304 RW 0x00000000 Bit 3: MSIE (Software Interrupt Enable) / Bit 7: MTIE (Timer Interrupt Enable) / Bit 11: MEIE (External Interrupt Enable) <code>mtvec</code> 0x305 RW 0x00000000 Bits 31:2: Base address (DIRECT ADDR ONLY SUPPOTED) <code>mscratch</code> 0x340 RW 0x00000000 Bits 31:0: Scratch data (general-purpose) <code>mepc</code> 0x341 RW 0x00000000 Bits 31:0: Exception program counter address <code>mcause</code> 0x342 RW 0x00000000 Bit 31: Interrupt flag / Bits 30:0: Exception/Interrupt code <code>mtval</code> 0x343 RW 0x00000000 Bits 31:0: Exception-specific value (faulting address or instruction) <code>mip</code> 0x344 RO 0x00000000 Bit 3: MSIP (Software Interrupt Pending) / Bit 7: MTIP (Timer Interrupt Pending) / Bit 11: MEIP (External Interrupt Pending)"},{"location":"data.md/#debug-csrs","title":"Debug CSRs","text":"Name Address Type Reset Value Bit Layout <code>dcsr</code> 0x7B0 RW 0x00000000 Bit 2: Step (single-step enabled) / Bits 8:6: Cause (debug entry reason) / Bits 15: ebreakm <code>dpc</code> 0x7B1 RW 0x00000000 Bits 31:0: Debug program counter (PC when entering debug mode) <code>dscratch0</code> 0x7B2 RW 0x00000000 Bits 31:0: Debug scratch register (general-purpose) <code>dscratch1</code> 0x7B3 RW 0x00000000 Bits 31:0: Debug scratch register (general-purpose)"},{"location":"data.md/#custom-csrs-list","title":"Custom CSRs list","text":"Name Address Type Reset Value Function <code>flush_cache</code> 0x7C0 WO 0x00000000 Cache flush command. Writing any value triggers cache flush; resets to 0 on next cycle. <code>data_non_cachable_base</code> 0x7C1 RW 0x00000000 Data non-cacheable base address. Sets lower bound of non-cacheable memory region. <code>data_non_cachable_limit</code> 0x7C2 RW 0xFFFFFFFF Data non-cacheable limit address. Sets upper bound of non-cacheable memory region. <code>instr_non_cachable_base</code> 0x7C3 RW 0x00000000 Instruction non-cacheable base address. Sets lower bound of non-cacheable instruction region. <code>instr_non_cachable_limit</code> 0x7C4 RW 0xFFFFFFFF Instruction non-cacheable limit address. Sets upper bound of non-cacheable instruction region."},{"location":"data.md/#mcause-values-and-mtval-contents","title":"<code>mcause</code> Values and <code>mtval</code> Contents","text":"mcause[31] mcause[30:0] Type Exception/Interrupt mtval Contains 0 0 Exception Instruction address misaligned Target address from second_adder (J/B target) 0 2 Exception Illegal instruction Current fetch instruction 0 3 Exception Breakpoint (ebreak) Current PC 0 4 Exception Load address misaligned Target address from ALU (load address) 0 6 Exception Store address misaligned Target address from ALU (store address) 0 11 Exception Environment call from M-mode (ecall) 0 1 3 Interrupt Machine software interrupt (MSIP) \u2014 1 7 Interrupt Machine timer interrupt (MTIP) \u2014 1 11 Interrupt Machine external interrupt (MEIP) \u2014"},{"location":"dev_docs/","title":"Dev Docs","text":"<p>Welcome to the Dev's documentation, a quick reference guide on how the HOLY CORE's microarchitecture works to quickly get up to speed.</p> <p>You'll also find here some guidelines and simulation tips.</p> <p>Info</p> <p>As you may already know, most of the CPU architecture is documented through the tutorials around which the HOLY CORE Course project is built around (the goal is for people to build it themselves with no experience if not basic HDL knwledge).</p> <p>Yet, the HOLY CORE is evolving from times to times and editions, features, bugs fixes, etc may be added witout being documented. These change smay be small or comletely change the whole datapath.</p> <p>To that reagrd, this document aims at giving an overview of the latest changes by going straight to the point as this document targets experience developper looking to check the latest microarchitecture cahnges to understand or modify it.</p>"},{"location":"dev_docs/#introduction","title":"Introduction","text":"<p>The HOLY_CORE is an open source RISCV-V core IP written entirly in systemVerilog.</p> <p>You'll see the core is extremely simple as it's a :</p> <ul> <li>no frontend...</li> <li>...no scoreboard...</li> <li>...single fetch...</li> <li>...single execution at a time...</li> <li>...single cycle CPU.</li> </ul> <p>The HOLY CORE uses two AXI interfaces (FULL and LITE) to fetch data from external peripherals from the <code>cache</code>/<code>no_cache</code> sub systems.</p> <p>The unit testbenches are done via cocotb, the backend simulator used is verilator and higher level verification of the ISA is done via RISCOF.</p> <p>Implementaion of the core is ensure by Xilinx tools (official support) but you can implement it in anything as look as there is enough LUTs. See User Docs for guidelines on how to actually use the HOLY CORE in your system.</p>"},{"location":"dev_docs/#rtl-contributions-guidelines","title":"RTL Contributions Guidelines","text":"<p>If you want to modify the HDL and contribute, please know that I am not interested in major architecture modifications (e.g. pipelining) without a careful planning process, contact me for more infos (you can use github issues).</p> <p>Typos fix are welcome changes.</p> <p>Docs improvements, code optimisations or more efficient synth code structure that could save LUTs and FFs are very welcome changes.</p> <p>When making an RTL change to a module, make sure you run the module's testbench, eventually add testcases to the said testbench, run the HOLY CORE quick testbench and then run the riscof test suite.</p> <p>This document will also guide you around all the simulation and verification tools available.</p> <p>Tip</p> <p>You can check out the <code>todo.md</code> file at the root of the project to see what are the projects things that should be done if you are looking for quick ways to participate.</p>"},{"location":"dev_docs/#core-overview","title":"Core Overview","text":""},{"location":"dev_docs/#scheme","title":"Scheme","text":"<p>As you can see, the HOLY CORE is simple. In fact, most of the important signals are on this scheme, though some subtle execution flows like traps or debug request are not made obvious here.</p>"},{"location":"dev_docs/#io-table","title":"I/O table","text":"Signal Direction Width Description <code>clk</code> Input 1 System clock <code>rst_n</code> Input 1 Active-low asynchronous reset <code>debug_req</code> Input 1 Debug request signal from debugger <code>debug_halt_addr</code> Input 32 Address to jump to when entering debug mode (debug ROM base address) <code>debug_exception_addr</code> Input 32 Address to jump to for debug exceptions (typically debug ROM + offset) <code>timer_itr</code> Input 1 Machine timer interrupt (MTIP) <code>soft_itr</code> Input 1 Machine software interrupt (MSIP) <code>ext_itr</code> Input 1 Machine external interrupt (MEIP) <code>m_axi</code> Output AXI Master AXI master interface for main memory access (instructions &amp; data) <code>m_axi_lite</code> Output AXI-Lite Master AXI-Lite master interface for peripheral/CSR access"},{"location":"dev_docs/#modules-functionalities","title":"Modules Functionalities","text":"<p>This part aims at briefly presenting the modules, what they do and their specificities.</p> <p>Note</p> <p>Modules' code can be found in the <code>hdl/</code> folder.</p>"},{"location":"dev_docs/#external-requests-arbiters","title":"External Requests Arbiters","text":"<p>It's not explicitly detailed in the scheme, but there are two arbiters :</p> <ul> <li><code>LITE ARBITRER</code></li> <li><code>FULL ARBITRER</code></li> </ul> <p>Because the HOLY CORE has CSRs to setup cached memory ranges (see user guide), we have to have 2 interface per cache (I$ and D$) : an AXI one to retrieve cache data and an AXI LITE one to interact with non cachable ranges.</p> <p>This means the holy core has 2 of each ! What the arbitrer do is keep track of what cache is using the interface (through the <code>serving</code> signal) and routes that request to the outside world until it's finished.</p>"},{"location":"dev_docs/#instruction-cache-i","title":"Instruction Cache (I$)","text":"<p>The instruction cache is also not detailed in the scheme but it's actually 2 separate module :</p> <ul> <li>Instruction Cache</li> <li>Instruction No cache</li> </ul> <p>This is because the HOLY CORE has CSRs to setup cached memory ranges (see user guide).</p> <p>The Instruction cache can only issue read requests.</p> <p>The core's data path determines if the requested PC is cachable or not and route the request to the right cache submodule ($ or NO$) using a handshake interface that looks like this :</p> Signal Name Direction Width Type Function <code>address</code> Input [31:0] Address Memory address for read/write transaction <code>read_data</code> Output [31:0] Data Data returned from memory read operation <code>req_valid</code> Input 1 bit Valid CPU asserts to indicate valid address and request <code>req_ready</code> Output 1 bit Ready Interface asserts to indicate ready to accept request <code>read_valid</code> Output 1 bit Valid Interface asserts when read_data is valid and available <code>read_ack</code> Input 1 bit Handshake CPU asserts to acknowledge/accept read_data <p>Tip</p> <p>Having a handshake interface with the CPU helps creating a more robust interface, which is essential when dealing with cache that pretty much go on with their life most of the time retrieving and sending data around.</p>"},{"location":"dev_docs/#data-cache-d","title":"Data Cache (D$)","text":"<p>The data cache is like the instruction cache, but the CPU also has a \"write\" handshake interface.</p> <p>Info</p> <p>Writes are non blocking and are accepted right away if the cache is idling, even if the cache misses.</p> <p>Just like the data cache, there are 2 submodules :</p> <ul> <li>Instruction Cache</li> <li>Instruction No cache</li> </ul> <p>This is because the HOLY CORE has CSRs to setup cached memory ranges (see user guide).</p> <p>The core's data path determines if the requested data address is cachable or not and route the request to the right cache submodule ($ or NO$) using a handshake interface that looks like this :</p> Signal Name Direction Width Type Function <code>address</code> Input [31:0] Address Memory address for read/write transaction <code>read_data</code> Output [31:0] Data Data returned from memory read operation <code>req_valid</code> Input 1 bit Valid CPU asserts to indicate valid address and request <code>req_ready</code> Output 1 bit Ready Interface asserts to indicate ready to accept request <code>read_valid</code> Output 1 bit Valid Interface asserts when read_data is valid and available <code>read_ack</code> Input 1 bit Handshake CPU asserts to acknowledge/accept read_data <p>The handshake delay can vary greatly depending on whether the cache missed or got a HIT.</p>"},{"location":"dev_docs/#stalling","title":"Stalling","text":"<p>The main stall signal depend on <code>i_cache_stall || d_cache_stall || alu_stall</code>, which all depend on their respective handshake state.</p> <p>Example</p> <p>If the control signal that we read from memory (via <code>mem_read_enable</code>) but the <code>data_read_valid</code> is low (or we did not acknowledged it via <code>data_read_ack</code>, then we stall to \"wait for the data request to be done\", same for writing requests (with <code>mem_write_enable</code>, <code>data_req_ready</code> and <code>data_req_valid</code>)) and same for instruction read requests.</p> <p>The stalling signal is central to this cpu, it is the only way (as there is no frontend to decide how to feed the hardware with instruction) to stop the execution flow in order to wait for something to be done. </p> <p>The <code>stall</code> signal is also used by rising edge sensitive module (alongside <code>instruction_valid</code>) to avoid writing data that is not valid yet because we'd have to wait for it to arrive.</p>"},{"location":"dev_docs/#alu-mdu","title":"ALU &amp; MDU","text":"<p>The HOLY_CORE supports M extension. For potential future evolutions of the core, the ALU and the Mul / Div Unit (MDU) are separated and requests are simply routed to on or another depending on the control signals.</p> <p>The ALU executes all the base RV32I operations in 1 cycle using pure comb logic, shift operations are executed in 1 cycle as well. The ALU also output flags during comparisons, used by the control unit to determine branch conditions.</p> <p>The MDU can execute MULs and DIVs. On FPGA, MUL are executed on DSP slices which takes no resources and can be executed in 1 cycle at virtually no cost</p> <p>Note</p> <p>There still is a 1 cycle delay in MUL operations for the read valid flag to go high (state machine transition induced delay) and allow DSP synth.</p> <p>DIVs however, take 32 clock cycles by shifting the divisor and comparing it to the dividen to extract result and remainder. During this process, the core is stalled.</p>"},{"location":"dev_docs/#control","title":"Control","text":"<p>The control modules acts as an instruction decoder and determines different control signals all over the data path (e.g. the <code>pc_source</code>).</p> <p>The control Unit also has the possibility to raise exceptions and to set a cause.</p> <p>Example</p> <p>An instruction can be invalid (Instruction memory corrupted) or an <code>ecall</code> was fetched...</p> <p>This <code>exception</code> flag, along with its cause are sent to the csr file to determine what to do.</p>"},{"location":"dev_docs/#csr-file","title":"CSR File","text":"<p>The CSR file contains the CSRs.</p> <p>But it also is the heart of all operations that goes beyond the simple RV32I instruction set like traps and debugging.</p> <p>It globally acts as the regular regfile in a way that it has register that we can read and write (addressable over 12 bits !) BUT it also outputs control signals to affect how the core behaves. For example : the CSR file has a control signal to flush the data cache, to mirror <code>mtvec</code>, <code>mepc</code> and <code>dpc</code> as a pc sources, or to set the cacheable ranges for I$ and D$.</p> <pre><code>It also has a `trap` signal that can [cause the core to trap when conditions are met](#trap-execution-flow).\n</code></pre> <p>Using these signals, the CSR file is what controls (alongside the <code>control</code> module) the execution flow.</p>"},{"location":"dev_docs/#trap-execution-flow","title":"Trap Execution Flow","text":"<p>Trapping occurs when :</p> <ul> <li>An exception occurs (flagged by the control unit)</li> <li>OR an interrupt request is received (mirrored in the csr file via <code>mip</code>) and the right trap flags are enable in <code>mie</code> and <code>mstatus</code>.</li> <li>AND the instruction fetched is flagged as valid.</li> <li>AND we are not currently trapping (tracked by the <code>trap_taken</code> register).</li> <li>AND a debug request is not being processed / We are not currently in debug mode</li> </ul> <pre><code>trap = (( (|(mie &amp; mip)) &amp;&amp; mstatus[3]) || exception) &amp;&amp; ~trap_taken &amp;&amp; ~debug_mode &amp;&amp; ~jump_to_debug;\n</code></pre> <p>Note</p> <p>So yeah, debug request have priority over traps here.</p> <p>If these conditions are met, the CSR file will assert its <code>trap</code> flag, set all the machine CSRs to the right value (in a riscv compliant way) and the control unit will use this <code>trap</code> flag to set <code>mtvec</code> as the <code>next_pc</code> source (where the trap handler code is).</p> <p>Info</p> <p><code>mtvec</code> is set by the user in assembly, not our problem but that means having a trap handler, even when not needed, is important to avoid provoking a jump to 0x0 when an exception rises.</p> <p>Note that the <code>trap</code> flag is only high for 1 cycle, the control unit latches on that <code>trap</code> flag if needed (e.g. in case of a <code>stall</code> that lasts multiple cycles) so no worries but a better way would be to have some handshake there.. That's a todo but it works this way so I kinda don't care.</p> <p>After that, the csr file will be in <code>trap_taken</code> mode and that will clear when <code>mret</code> is signaled by the control unit, in which case <code>pc_next</code> will also be set to <code>mepc</code> to resume normal program execution after that, the trap will be able to trap again.</p>"},{"location":"dev_docs/#debug-execution-flow","title":"Debug Execution Flow","text":"<p>Info</p> <p>Learn more about the debugging flow in the External Debug Support specs, especially the \"A.2 Execution Based\" chapter.</p> <p>Debug works like traps.</p> <p>We can find similar elements:</p> <ul> <li>A <code>jump_to_debug</code> flag, sent to the control unit when the conditions are met.</li> <li>Some debug CSRs that are updated in a standard way when entering the debug mode</li> <li>etc ...</li> </ul> <p>But there are a couple of specificities in the hardware implementation :</p> <ul> <li>Debug requests don't interfere with trap handling flow.</li> <li><code>ebreak</code> can jump to debug (instead of trap handler), considered as a software breakpoint depending on <code>dcsr[15:12]</code> values</li> <li>A <code>step</code> flag can be step by the debugger in <code>dcsr[2]</code>, which immidiatly asserts <code>jump_to_debug</code>, effectively giving control back to the debugger once a single instruction is executed.</li> <li>Exceptions in debug mode do not trap but jump to the debug module's exception handler.</li> </ul>"},{"location":"dev_docs/#register-file","title":"Register File","text":"<p>The register file is a standard async read, sync write register file addressable via 5bits and containing 32 registers.</p> <p>The <code>x0</code> register is tied to GND and cannot have any other value than 0.</p>"},{"location":"dev_docs/#sign-extender-imm-decoder","title":"Sign Extender / Imm Decoder","text":"<p>Info</p> <p>Immediate decoder is also called \"sign extender\" because of legacy naming.</p> <p>The immediate decoder's role is to extract the immediate out of the instruction being fetched.</p> <p>The way the immediate is extracted depends on the control signal sent by the main instruction decoder (the control unit).</p>"},{"location":"dev_docs/#second-adder","title":"Second Adder","text":"<p>Below the main ALU is a second 32bits adder named \"second adder\" in the code base.</p> <p>The second adder's role is to compute branch and jump targets and every other pc-related values (e.g. values needed for <code>auipc</code>).</p> <p>The second adder's result can also be used to access directly the immediate's result. This is not very intuitive though and I could just have the immediate value wired to the write back MUX. I was not really clever on this one back then and that's a todo.</p> <p>In theory, this second adder should only be used to compute pc related values and be embedded in a branching unit that would separate the branch logic from the main decoder, which makes more sense when pipelining even though not mandatory.</p> <p>Again, that is a refactorization todo but this whole second adder thing works so I figured I would do that later. Chances are I'll never do it haha.</p>"},{"location":"dev_docs/#alu","title":"ALU","text":"<p>The ALU is a standard one cycle ALU. It does not have any busy flags and executes all operations in 1 cycle.</p> <p>This is not the best for performance, but adding some busy flags + a handshake would complexify the \"execution part\" and I thought it was not really the priority.</p>"},{"location":"dev_docs/#loadstore-decoder","title":"Load/Store Decoder","text":"<p>The load/store decoder's role is to compute the <code>byte_enable</code> mask for reads and writes.</p> <p>In case of a write that is not a full word, it also aligns the data correctly before feeding it to the data memory.</p>"},{"location":"dev_docs/#reader","title":"Reader","text":"<p>The reader's role is to format the read data coming from the data cache by aligning the data correctly and applying the <code>byte_enable</code> mask (if not a full word).</p>"},{"location":"dev_docs/#write-back-mux","title":"Write Back Mux","text":"<p>The write back mux is not a module but is an important step as pipelined architectures give it its own stage.</p> <p>Its role is to select the right data source to feed back in the registers and produce a valid signal to assert the data is valid.</p> <p>The regfile then applies the read.</p>"},{"location":"dev_docs/#dev-workflow-simulation","title":"Dev Workflow &amp; Simulation","text":""},{"location":"dev_docs/#verification-software-stack","title":"Verification Software Stack","text":"<p>For the whole HOLY CORE course, we use cocotb + verilator for simulation and assertions.</p> <p>You have a document to setup your work environment in the repo : \"setup.md\".</p> <p>Warning</p> <p>Make sure you're all setup correctly to verify the things you make, this is mandatory.</p>"},{"location":"dev_docs/#generic-rtl-changes-testing-workflow","title":"Generic RTL Changes &amp; Testing Workflow","text":""},{"location":"dev_docs/#navigating-and-using-the-tb-folder-for-submodules","title":"Navigating and Using the tb/ Folder for submodules","text":"<p>When making improvements to the codebase, it is mandatory to verify the submodule you just modified.</p> <p>You can learn more about how a basic cocotb testbench is structured and how it works in this blog post or on the cocotb website. In a nutshell, you use a python file as a frontend that cocotb will use to run assertion by simulating the design in the backend using whatever simulator you want, in our case, Verilator.</p> <p>To verify, <code>cd</code> into <code>&lt;edition_root&gt;/tb/&lt;module_name&gt;</code> and run <code>make</code>.</p> <p>If you added significant changes, make sure you add the adequate test cases to the cocotb python file.</p> <p>Once your changes are verified, cd back into <code>tb/</code> and run <code>pytest test_runner.py</code>, this will run all tests on all submodules.</p> <p>Note</p> <p>Running the cocotb testbench for <code>tb/holy_core</code> is slightly different, more infos below.</p> <p>Bug</p> <p>Sometimes, the tests fail with no real reason, cd back to the edition's root and run <code>make clean</code> to clean up all simulation builds and retry <code>pytest test_runner.py</code> in the <code>tb/</code> folder.</p>"},{"location":"dev_docs/#verifying-the-holy-core-using-the-cocotb-testbench","title":"Verifying the HOLY CORE using the cocotb testbench","text":""},{"location":"dev_docs/#testbench-structure","title":"Testbench Structure","text":"<p>When changing some elements in the code, it is important to have a quick way to verify if our changes broke something. Verifying the core is especially long with methods like the RISCOF framework.</p> <p>This is why a simple cocotb HOLY CORE testbench was developed.</p> <p>Just like any other submodule, you can verify the core running a simple make command : <code>make sim</code>.</p> <p>Note, the <code>sim</code> added after make : this is because make alone builds the <code>test.S</code> program the core is tested against.</p> <p>Here is the <code>tb/holy_core/</code> file structure in details :</p> <pre><code>tb/holy_core\n\u251c\u2500\u2500 axi_if_convert.sv       Top wrapper used to convert axi interfaces for cocotb to understand\n\u251c\u2500\u2500 holy_test_harness.sv    Harness wrapper embedding some peripherals. See it as a stripped down holy_top.sv\n\u251c\u2500\u2500 Makefile                Builds test.S into a .hex file and runs sim. \n\u251c\u2500\u2500 old                     Misc\n\u251c\u2500\u2500 test_dmemory.hex        Legacy memory init file (still used)\n\u251c\u2500\u2500 test_holy_core.py       Cocotb assertions\n\u2514\u2500\u2500 test.s                  Actual test program\n</code></pre> <p>As you can see, there is a test harness and a top wrapper that goes around the HOLY CORE that embeds basic peripherals that the test program will use to test basic SoC interaction :</p> <p></p>"},{"location":"dev_docs/#test-program","title":"Test Program","text":"<p>The <code>test.S</code> programs runs the HOLY CORE through basic instructions and the cocotb testbench runs assertions to make sure these simple test cases executed as expected.</p> <p>When running <code>make sim</code>, it is compiled into an elf and dumped into a <code>.hex</code> file, which cocotb can read, interpret and load into its simulated memory that the core will then access as regular memory to fetch instruction and run data transactions.</p> <p>It also runs the core through some basic trap and debug flow to check the core's behavior is correct and compliant as these are not tested by riscof and are complicated to test otherwise.</p> <p>This basic testbench for the HOLY CORE is the best dev tool to quickly verify your changes did not break everything, once your changes are verified and this test passes, you can move on to verifying using RISCOF.</p>"},{"location":"dev_docs/#verifying-the-core-using-riscof","title":"Verifying the core using RISCOF","text":"<p>The RISCOF verification framework is far more \"heavyweight\" than the basic tests we detailed in \"Verifying the HOLY CORE using the cocotb testbench\".</p> <p>This document will not explain how RISCOF works. Nor how the plugin is built as this is too dense and detailed extensively in the tutorials.</p> <p>The RISCOF verification happens in the <code>riscof/</code> folder :</p> <pre><code>riscof\n\u251c\u2500\u2500 config.ini          Riscof Hints\n\u251c\u2500\u2500 holy_core           Contains the HOLY CORE riscof plugin\n\u251c\u2500\u2500 holy_core_tb        Contains a holy core cocotb testbench, adapted especially for riscof\n\u251c\u2500\u2500 Makefile            Cleanup makefile\n\u251c\u2500\u2500 readme.md           Guide on how to setup and run RISCOF tests\n\u251c\u2500\u2500 riscof_work         (Once you run the test) contains all the results\n\u251c\u2500\u2500 riscv-arch-test     (Once you run the test) contains all the RV tests source code\n\u251c\u2500\u2500 spike               Contains the reference simulator riscof plugin\n\u2514\u2500\u2500 testlist.yaml       Not used\n</code></pre> <p>In the backstage, RISCOF will use a cocotb testbench to test each program and dump the tests results into a signature file, which will get compared to a reference signature file (from the SPIKE Risc-V simulator).</p> <p>To run the tests, a guide already exists in the <code>riscof/readme.md</code> file.</p> <p>Note</p> <p>RISCOF tests executions (on the HOLY CORE) are all preceded by the execution of <code>riscof/holy_core_tb/test_startup.S</code>, which ironically also contains a test end macro.</p> <p>The goal of this very small piece of code is to setup the caches and set everything as non cachable, meaning all RISCOF tests run as fully cached.</p> <p>The test end makes sure to flush the cache before fully ending the test.</p> <p>This piece of code is entirely customizable to your need to ease debugging, make sure you build it correctly with <code>make -f start.Makefile</code></p>"},{"location":"dev_docs/#riscof-debugging-guidelines","title":"RISCOF Debugging Guidelines","text":"<p>RISCOF runs tests and compares signatures, but it offers little to no debug utilities.</p> <p>Fortunately, we have excellent ways to debug the HOLY CORE if a test fails.</p> <p>In the <code>riscof/riscof_work</code> folder lies all the tests results. Here's the <code>add</code> test sim results as an example:</p> <pre><code>riscof/riscof_work/rv32i_m/I/src/add-01.S\n\u251c\u2500\u2500 dut\n\u2502   \u251c\u2500\u2500 dump.vcd                        HOLY CORE waveforms\n\u2502   \u251c\u2500\u2500 DUT-holy_core.signature         Signature file (should be same as Reference-spike.signature)\n\u2502   \u251c\u2500\u2500 dut.log                         Spike-like CPU logs\n\u2502   \u251c\u2500\u2500 dut.symbols                     Test elf's symbols\n\u2502   \u251c\u2500\u2500 my.bin                          Test bin\n\u2502   \u251c\u2500\u2500 my.elf                          Test elf\n\u2502   \u251c\u2500\u2500 my.hex                          Test hex\n\u2502   \u2514\u2500\u2500 tb_messages.log                 Cocotb logs\n\u2514\u2500\u2500 ref\n    \u251c\u2500\u2500 my.elf                          Test elf\n    \u251c\u2500\u2500 Reference-spike.signature       Spike ref signature\n    \u2514\u2500\u2500 ref.log                         Spike CPU logs\n</code></pre> <p>If you know the test fails from the report, you can use these results to investigate.</p> <p>First of all, use <code>tb_messages.log</code> to check if the cocotb test went well, if it failed, investigate on this error first (syntax ? forgot to cleanup ? error loading the program ? etc).</p> <p>Then, a great tool to know exactly when the HOLY CORE FAILED to follow a \"compliant execution flow\" is to use <code>dut.log</code> and <code>ref.log</code>.</p> <p>These logging files trace back all register, csr, memory and pc transaction / evolutions, which allows the dev (you) to pinpoint exactly when the CPU failed to execute the program in a compliant way and therefore fail the test.</p> <p>Once the exact failure point in the simulation has been identified, you can use the waveform and your knowledge of the RISC-V specs to patch the HDL accordingly.</p>"},{"location":"dev_docs/#simulating-real-program-execution","title":"Simulating Real Program Execution","text":"<p>Sometimes, RISCOF tests pass but bugs (unexpected exceptions) occur when testing a piece of software on FPGA.</p> <p>It may not always be due to hardware bugs, but it may be and sometimes, all the software debugging tools are not enough to clear that doubt.</p> <p>A good solution to clear that doubt (or shed light on a specific edge case bug) is to simulate the actual software execution.</p> <p>To do so, in <code>fpga/</code>, you have access to another cocotb testbench : <code>test_run_lint.py</code>. (named \"lint\" as it was first built to lint <code>holy_top.sv</code>).</p> <p>This testbench simulates the holy_top.sv internal base SoC directly and the whole externals are just cocotb simulated RAM slaves :</p> <p></p> <p>What this testbench do is load whatever <code>.hex</code> dump file you specify in the simulated memory and release reset.</p>"},{"location":"dev_docs/#prepare-your-program","title":"Prepare your Program","text":"<p>To simulate your program, you first need to get it into a hex dump format. The <code>example_program</code> folder allows you to build software and automatically generate the said hexdump in the right format.</p> <p>Once this is done, you can specify the following in <code>test_run_lint.py</code> :</p> <pre><code>hex_path = \"path_to_your_hex.hex\"\n</code></pre>"},{"location":"dev_docs/#prepare-the-holy_topsv-soc","title":"Prepare the <code>holy_top.sv</code> SoC","text":"<p>The real <code>holy_top.sv</code> gets simulated with your program in memory here.</p> <p>BUT :</p> <ul> <li>The program gets loaded at address 0x80000000</li> <li>The CPU start (boots) at PC = 0x00000000</li> <li>The code at 0x00000000 is the one in the BOOT ROM</li> </ul> <p>And remember, by default, the ROM implement an FPGA park loop to wait for the User to connect with a debugger.</p> <p>That means you should modify the boot rom to jump to 0x80000000 with a program that looks like this:</p> <pre><code>    .global _start\n\n_start:\n    # ==============================================\n    # for TestBench : Jump to Main program directly\n    # ==============================================\n\n    # Example of sim start sequence : setup cache if needed\n    # data cache setup\n    li t0, 0x0\n    li t0, 0x7FFFFFFF\n    csrrw x0, 0x7C1, t0\n    csrrw x0, 0x7C2, t1\n\n    # instr cache setup\n    li t0, 0x0\n    li t1, 0x7FFFFFFF\n    csrrw x0, 0x7C3, t0\n    csrrw x0, 0x7C4, t1\n\n    // jump to program in cocotb's ram\n    la t0, 0x80000000\n    jalr x0, t0, 0   \n</code></pre> <p>And your program should start executing.</p> <p>You can of course modify <code>test_run_lint.py</code> to fit your needs and stop the test whenever a condition is met (e.g. an exception has been met or a predefined PC has been reached...)</p> <p>You can use this useful simulation tool to :</p> <ul> <li>Profile a program's performance (e.g. IPC/CPI)</li> <li>Reproduce software bugs in simulation</li> <li>test SoC components behavior (CLINT, PLIC, ...)</li> </ul> <p>Note</p> <p>Make sure you restore <code>rom.s</code> and rebuild it like it was before to avoid unexpected bugs for future FPGA users.</p>"},{"location":"showcase/","title":"Showcase","text":"<p>You might be wondering what the HOLY CORE can actually do.</p> <p>This section showcases a few projects built on top of the HOLY CORE to give a concrete idea of its capabilities and maturity.</p> <p>Add your project</p> <p>You can contribute to these docs and add your own project here!</p>"},{"location":"showcase/#doom","title":"DOOM","text":"<p>The HOLY CORE runs DOOM.</p> <p></p> <p>Running DOOM was far from trivial, but it proved extremely valuable. It exposed several design flaws early on and ultimately demonstrated that the overall architecture is reasonably reliable (with caches enabled).</p> <p>Performance-wise, there is still room for improvement. The main bottleneck is SPI data transfer, which currently limits the achievable FPS. This could be addressed by increasing the system frequency so both the core and SPI IP run faster, or by adding offloading logic such as a DMA-like mechanism.</p> <p>More ambitious improvements would include pipelining the core and adding a scoreboard to allow multiple instructions to be in flight at once (for example, issuing an ALU operation while a load is still completing). For the purpose of a demo, however, the current implementation felt \u201cgood enough\u201d, and I chose to move on to other projects.</p> <p>Note</p> <p>You can check out the code here.</p>"},{"location":"showcase/#uart-interrupt-based-shell","title":"UART Interrupt-Based Shell","text":"<p>A simple UART-based shell available in <code>example_programs/</code>.</p> <p>All interactions are interrupt-driven, while the main program itself is just an infinite loop.</p> <p></p> <p>This was the first project heavily relying on interrupts, and it involved many moving parts. Implementing a basic core is one thing; correctly handling interrupts and exceptions is a completely different challenge\u2014and, in my opinion, significantly harder than implementing RV32I itself.</p> <p>You need to understand the relevant standards, implement CSRs (which essentially means supporting the Zicsr extension), carefully follow the specification for every corner case, and then somehow verify that everything behaves as expected.</p> <p>On top of that, interrupts do not manage themselves. You need interrupt controller cores, and since there is no simple plug-and-play solution, you will most likely end up implementing your own CLINT and PLIC.</p> <p>Getting this project to work was especially satisfying, as it represents the result of extensive specification research, design work, and verification, not even counting FPGA integration.</p>"},{"location":"showcase/#interrupt-based-pong-game","title":"Interrupt-Based Pong Game","text":"<p>Another interrupt-driven project, this time with a more dynamic workload: a simple PONG game.</p> <p></p> <p>Interrupts are used to update global variables, which are then consumed by the main loop to update the game state. The current state of the game is displayed over UART.</p> <p>Using interrupts allows for a much cleaner game logic and demonstrates that interrupts work reliably beyond the simpler shell scenario. It also shows that the HOLY CORE can handle a quasi \u201creal-time\u201d environment, where a task is constantly running and interrupts are only used to update small pieces of state to avoid excessive CPU usage.</p> <p>(The flickering cursor is just a UART artifact\u2014nothing more.)</p> <p>This project was the natural next step after the UART shell and further validates the interrupt subsystem in a more realistic use case.</p>"}]}